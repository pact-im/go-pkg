<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Source: synctest.go in package testing/synctest</title>
<link href="../../../css/auto-v0.7.6.css" rel="stylesheet">
<script src="../../../jvs/golds-v0.7.6.js"></script>
<body onload="onPageLoad()"><div>

<pre id="header"><code><span class="title">Source File</span>
	synctest.go

<span class="title">Belonging Package</span>
	<a href="../../../pkg/testing/synctest.html">testing/synctest</a>
</code></pre>
<style>input[type=radio] {display: none;}
input[id=r0]:checked ~pre label[for=r0],
input[id=r1]:checked ~pre label[for=r1],
input[id=r2]:checked ~pre label[for=r2],
input[id=r3]:checked ~pre label[for=r3],
input[id=r4]:checked ~pre label[for=r4],
input[id=r5]:checked ~pre label[for=r5],
input[id=r6]:checked ~pre label[for=r6],
input[id=r7]:checked ~pre label[for=r7]
{background: #226; color: #ff8;}
input[id=i0]:checked ~pre .i0,
input[id=i1]:checked ~pre .i1,
input[id=i2]:checked ~pre .i2
{background: brown; color: #eed;}
</style><input id="r0" type="radio" name="g"/>
<input id="r1" type="radio" name="g"/>
<input id="r2" type="radio" name="g"/>
<input id="r3" type="radio" name="g"/>
<input id="r4" type="radio" name="g"/>
<input id="r5" type="radio" name="g"/>
<input id="r6" type="radio" name="g"/>
<input id="r7" type="radio" name="g"/>
<input id="i0" type="radio" name="i"/>
<input id="i1" type="radio" name="i"/>
<input id="i2" type="radio" name="i"/>

<pre class="line-numbers">
<span class="codeline" id="line-1"><code><span class="comment">// Copyright 2024 The Go Authors. All rights reserved.</span></code></span>
<span class="codeline" id="line-2"><code><span class="comment">// Use of this source code is governed by a BSD-style</span></code></span>
<span class="codeline" id="line-3"><code><span class="comment">// license that can be found in the LICENSE file.</span></code></span>
<span class="codeline" id="line-4"><code></code></span>
<div class="anchor" id="doc"><span class="codeline" id="line-5"><code><span class="comment">// Package synctest provides support for testing concurrent code.</span></code></span>
<span class="codeline" id="line-6"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-7"><code><span class="comment">// The [Test] function runs a function in an isolated "bubble".</span></code></span>
<span class="codeline" id="line-8"><code><span class="comment">// Any goroutines started within the bubble are also part of the bubble.</span></code></span>
<span class="codeline" id="line-9"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-10"><code><span class="comment">// # Time</span></code></span>
<span class="codeline" id="line-11"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-12"><code><span class="comment">// Within a bubble, the [time] package uses a fake clock.</span></code></span>
<span class="codeline" id="line-13"><code><span class="comment">// Each bubble has its own clock.</span></code></span>
<span class="codeline" id="line-14"><code><span class="comment">// The initial time is midnight UTC 2000-01-01.</span></code></span>
<span class="codeline" id="line-15"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-16"><code><span class="comment">// Time in a bubble only advances when every goroutine in the</span></code></span>
<span class="codeline" id="line-17"><code><span class="comment">// bubble is durably blocked.</span></code></span>
<span class="codeline" id="line-18"><code><span class="comment">// See below for the exact definition of "durably blocked".</span></code></span>
<span class="codeline" id="line-19"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-20"><code><span class="comment">// For example, this test runs immediately rather than taking</span></code></span>
<span class="codeline" id="line-21"><code><span class="comment">// two seconds:</span></code></span>
<span class="codeline" id="line-22"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-23"><code><span class="comment">//	func TestTime(t *testing.T) {</span></code></span>
<span class="codeline" id="line-24"><code><span class="comment">//		synctest.Test(t, func(t *testing.T) {</span></code></span>
<span class="codeline" id="line-25"><code><span class="comment">//			start := time.Now() // always midnight UTC 2000-01-01</span></code></span>
<span class="codeline" id="line-26"><code><span class="comment">//			go func() {</span></code></span>
<span class="codeline" id="line-27"><code><span class="comment">//				time.Sleep(1 * time.Second)</span></code></span>
<span class="codeline" id="line-28"><code><span class="comment">//				t.Log(time.Since(start)) // always logs "1s"</span></code></span>
<span class="codeline" id="line-29"><code><span class="comment">//			}()</span></code></span>
<span class="codeline" id="line-30"><code><span class="comment">//			time.Sleep(2 * time.Second) // the goroutine above will run before this Sleep returns</span></code></span>
<span class="codeline" id="line-31"><code><span class="comment">//			t.Log(time.Since(start))    // always logs "2s"</span></code></span>
<span class="codeline" id="line-32"><code><span class="comment">//		})</span></code></span>
<span class="codeline" id="line-33"><code><span class="comment">//	}</span></code></span>
<span class="codeline" id="line-34"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-35"><code><span class="comment">// Time stops advancing when the root goroutine of the bubble exits.</span></code></span>
<span class="codeline" id="line-36"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-37"><code><span class="comment">// # Blocking</span></code></span>
<span class="codeline" id="line-38"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-39"><code><span class="comment">// A goroutine in a bubble is "durably blocked" when it is blocked</span></code></span>
<span class="codeline" id="line-40"><code><span class="comment">// and can only be unblocked by another goroutine in the same bubble.</span></code></span>
<span class="codeline" id="line-41"><code><span class="comment">// A goroutine which can be unblocked by an event from outside its</span></code></span>
<span class="codeline" id="line-42"><code><span class="comment">// bubble is not durably blocked.</span></code></span>
<span class="codeline" id="line-43"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-44"><code><span class="comment">// The [Wait] function blocks until all other goroutines in the</span></code></span>
<span class="codeline" id="line-45"><code><span class="comment">// bubble are durably blocked.</span></code></span>
<span class="codeline" id="line-46"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-47"><code><span class="comment">// For example:</span></code></span>
<span class="codeline" id="line-48"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-49"><code><span class="comment">//	func TestWait(t *testing.T) {</span></code></span>
<span class="codeline" id="line-50"><code><span class="comment">//		synctest.Test(t, func(t *testing.T) {</span></code></span>
<span class="codeline" id="line-51"><code><span class="comment">//			done := false</span></code></span>
<span class="codeline" id="line-52"><code><span class="comment">//			go func() {</span></code></span>
<span class="codeline" id="line-53"><code><span class="comment">//				done = true</span></code></span>
<span class="codeline" id="line-54"><code><span class="comment">//			}()</span></code></span>
<span class="codeline" id="line-55"><code><span class="comment">//			// Wait will block until the goroutine above has finished.</span></code></span>
<span class="codeline" id="line-56"><code><span class="comment">//			synctest.Wait()</span></code></span>
<span class="codeline" id="line-57"><code><span class="comment">//			t.Log(done) // always logs "true"</span></code></span>
<span class="codeline" id="line-58"><code><span class="comment">//		})</span></code></span>
<span class="codeline" id="line-59"><code><span class="comment">//	}</span></code></span>
<span class="codeline" id="line-60"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-61"><code><span class="comment">// When every goroutine in a bubble is durably blocked:</span></code></span>
<span class="codeline" id="line-62"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-63"><code><span class="comment">//   - [Wait] returns, if it has been called.</span></code></span>
<span class="codeline" id="line-64"><code><span class="comment">//   - Otherwise, time advances to the next time that will</span></code></span>
<span class="codeline" id="line-65"><code><span class="comment">//     unblock at least one goroutine, if there is such a time</span></code></span>
<span class="codeline" id="line-66"><code><span class="comment">//     and the root goroutine of the bubble has not exited.</span></code></span>
<span class="codeline" id="line-67"><code><span class="comment">//   - Otherwise, there is a deadlock and [Test] panics.</span></code></span>
<span class="codeline" id="line-68"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-69"><code><span class="comment">// The following operations durably block a goroutine:</span></code></span>
<span class="codeline" id="line-70"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-71"><code><span class="comment">//   - a blocking send or receive on a channel created within the bubble</span></code></span>
<span class="codeline" id="line-72"><code><span class="comment">//   - a blocking select statement where every case is a channel created</span></code></span>
<span class="codeline" id="line-73"><code><span class="comment">//     within the bubble</span></code></span>
<span class="codeline" id="line-74"><code><span class="comment">//   - [sync.Cond.Wait]</span></code></span>
<span class="codeline" id="line-75"><code><span class="comment">//   - [sync.WaitGroup.Wait], when [sync.WaitGroup.Add] was called within the bubble</span></code></span>
<span class="codeline" id="line-76"><code><span class="comment">//   - [time.Sleep]</span></code></span>
<span class="codeline" id="line-77"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-78"><code><span class="comment">// Operations not in the above list are not durably blocking.</span></code></span>
<span class="codeline" id="line-79"><code><span class="comment">// In particular, the following operations may block a goroutine,</span></code></span>
<span class="codeline" id="line-80"><code><span class="comment">// but are not durably blocking because the goroutine can be unblocked</span></code></span>
<span class="codeline" id="line-81"><code><span class="comment">// by an event occurring outside its bubble:</span></code></span>
<span class="codeline" id="line-82"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-83"><code><span class="comment">//   - locking a [sync.Mutex] or [sync.RWMutex]</span></code></span>
<span class="codeline" id="line-84"><code><span class="comment">//   - blocking on I/O, such as reading from a network socket</span></code></span>
<span class="codeline" id="line-85"><code><span class="comment">//   - system calls</span></code></span>
<span class="codeline" id="line-86"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-87"><code><span class="comment">// # Isolation</span></code></span>
<span class="codeline" id="line-88"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-89"><code><span class="comment">// A channel, [time.Timer], or [time.Ticker] created within a bubble</span></code></span>
<span class="codeline" id="line-90"><code><span class="comment">// is associated with it. Operating on a bubbled channel, timer, or</span></code></span>
<span class="codeline" id="line-91"><code><span class="comment">// ticker from outside the bubble panics.</span></code></span>
<span class="codeline" id="line-92"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-93"><code><span class="comment">// A [sync.WaitGroup] becomes associated with a bubble on the first</span></code></span>
<span class="codeline" id="line-94"><code><span class="comment">// call to Add or Go. Once a WaitGroup is associated with a bubble,</span></code></span>
<span class="codeline" id="line-95"><code><span class="comment">// calling Add or Go from outside that bubble is a fatal error.</span></code></span>
<span class="codeline" id="line-96"><code><span class="comment">// (As a technical limitation, a WaitGroup defined as a package</span></code></span>
<span class="codeline" id="line-97"><code><span class="comment">// variable, such as "var wg sync.WaitGroup", cannot be associated</span></code></span>
<span class="codeline" id="line-98"><code><span class="comment">// with a bubble and operations on it may not be durably blocking.</span></code></span>
<span class="codeline" id="line-99"><code><span class="comment">// This limitation does not apply to a *WaitGroup stored in a</span></code></span>
<span class="codeline" id="line-100"><code><span class="comment">// package variable, such as "var wg = new(sync.WaitGroup)".)</span></code></span>
<span class="codeline" id="line-101"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-102"><code><span class="comment">// [sync.Cond.Wait] is durably blocking. Waking a goroutine in a bubble</span></code></span>
<span class="codeline" id="line-103"><code><span class="comment">// blocked on Cond.Wait from outside the bubble is a fatal error.</span></code></span>
<span class="codeline" id="line-104"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-105"><code><span class="comment">// Cleanup functions and finalizers registered with</span></code></span>
<span class="codeline" id="line-106"><code><span class="comment">// [runtime.AddCleanup] and [runtime.SetFinalizer]</span></code></span>
<span class="codeline" id="line-107"><code><span class="comment">// run outside of any bubble.</span></code></span>
<span class="codeline" id="line-108"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-109"><code><span class="comment">// # Example: Context.AfterFunc</span></code></span>
<span class="codeline" id="line-110"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-111"><code><span class="comment">// This example demonstrates testing the [context.AfterFunc] function.</span></code></span>
<span class="codeline" id="line-112"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-113"><code><span class="comment">// AfterFunc registers a function to execute in a new goroutine</span></code></span>
<span class="codeline" id="line-114"><code><span class="comment">// after a context is canceled.</span></code></span>
<span class="codeline" id="line-115"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-116"><code><span class="comment">// The test verifies that the function is not run before the context is canceled,</span></code></span>
<span class="codeline" id="line-117"><code><span class="comment">// and is run after the context is canceled.</span></code></span>
<span class="codeline" id="line-118"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-119"><code><span class="comment">//	func TestContextAfterFunc(t *testing.T) {</span></code></span>
<span class="codeline" id="line-120"><code><span class="comment">//		synctest.Test(t, func(t *testing.T) {</span></code></span>
<span class="codeline" id="line-121"><code><span class="comment">//			// Create a context.Context which can be canceled.</span></code></span>
<span class="codeline" id="line-122"><code><span class="comment">//			ctx, cancel := context.WithCancel(t.Context())</span></code></span>
<span class="codeline" id="line-123"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-124"><code><span class="comment">//			// context.AfterFunc registers a function to be called</span></code></span>
<span class="codeline" id="line-125"><code><span class="comment">//			// when a context is canceled.</span></code></span>
<span class="codeline" id="line-126"><code><span class="comment">//			afterFuncCalled := false</span></code></span>
<span class="codeline" id="line-127"><code><span class="comment">//			context.AfterFunc(ctx, func() {</span></code></span>
<span class="codeline" id="line-128"><code><span class="comment">//				afterFuncCalled = true</span></code></span>
<span class="codeline" id="line-129"><code><span class="comment">//			})</span></code></span>
<span class="codeline" id="line-130"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-131"><code><span class="comment">//			// The context has not been canceled, so the AfterFunc is not called.</span></code></span>
<span class="codeline" id="line-132"><code><span class="comment">//			synctest.Wait()</span></code></span>
<span class="codeline" id="line-133"><code><span class="comment">//			if afterFuncCalled {</span></code></span>
<span class="codeline" id="line-134"><code><span class="comment">//				t.Fatalf("before context is canceled: AfterFunc called")</span></code></span>
<span class="codeline" id="line-135"><code><span class="comment">//			}</span></code></span>
<span class="codeline" id="line-136"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-137"><code><span class="comment">//			// Cancel the context and wait for the AfterFunc to finish executing.</span></code></span>
<span class="codeline" id="line-138"><code><span class="comment">//			// Verify that the AfterFunc ran.</span></code></span>
<span class="codeline" id="line-139"><code><span class="comment">//			cancel()</span></code></span>
<span class="codeline" id="line-140"><code><span class="comment">//			synctest.Wait()</span></code></span>
<span class="codeline" id="line-141"><code><span class="comment">//			if !afterFuncCalled {</span></code></span>
<span class="codeline" id="line-142"><code><span class="comment">//				t.Fatalf("before context is canceled: AfterFunc not called")</span></code></span>
<span class="codeline" id="line-143"><code><span class="comment">//			}</span></code></span>
<span class="codeline" id="line-144"><code><span class="comment">//		})</span></code></span>
<span class="codeline" id="line-145"><code><span class="comment">//	}</span></code></span>
<span class="codeline" id="line-146"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-147"><code><span class="comment">// # Example: Context.WithTimeout</span></code></span>
<span class="codeline" id="line-148"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-149"><code><span class="comment">// This example demonstrates testing the [context.WithTimeout] function.</span></code></span>
<span class="codeline" id="line-150"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-151"><code><span class="comment">// WithTimeout creates a context which is canceled after a timeout.</span></code></span>
<span class="codeline" id="line-152"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-153"><code><span class="comment">// The test verifies that the context is not canceled before the timeout expires,</span></code></span>
<span class="codeline" id="line-154"><code><span class="comment">// and is canceled after the timeout expires.</span></code></span>
<span class="codeline" id="line-155"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-156"><code><span class="comment">//	func TestContextWithTimeout(t *testing.T) {</span></code></span>
<span class="codeline" id="line-157"><code><span class="comment">//		synctest.Test(t, func(t *testing.T) {</span></code></span>
<span class="codeline" id="line-158"><code><span class="comment">//			// Create a context.Context which is canceled after a timeout.</span></code></span>
<span class="codeline" id="line-159"><code><span class="comment">//			const timeout = 5 * time.Second</span></code></span>
<span class="codeline" id="line-160"><code><span class="comment">//			ctx, cancel := context.WithTimeout(t.Context(), timeout)</span></code></span>
<span class="codeline" id="line-161"><code><span class="comment">//			defer cancel()</span></code></span>
<span class="codeline" id="line-162"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-163"><code><span class="comment">//			// Wait just less than the timeout.</span></code></span>
<span class="codeline" id="line-164"><code><span class="comment">//			time.Sleep(timeout - time.Nanosecond)</span></code></span>
<span class="codeline" id="line-165"><code><span class="comment">//			synctest.Wait()</span></code></span>
<span class="codeline" id="line-166"><code><span class="comment">//			if err := ctx.Err(); err != nil {</span></code></span>
<span class="codeline" id="line-167"><code><span class="comment">//				t.Fatalf("before timeout: ctx.Err() = %v, want nil\n", err)</span></code></span>
<span class="codeline" id="line-168"><code><span class="comment">//			}</span></code></span>
<span class="codeline" id="line-169"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-170"><code><span class="comment">//			// Wait the rest of the way until the timeout.</span></code></span>
<span class="codeline" id="line-171"><code><span class="comment">//			time.Sleep(time.Nanosecond)</span></code></span>
<span class="codeline" id="line-172"><code><span class="comment">//			synctest.Wait()</span></code></span>
<span class="codeline" id="line-173"><code><span class="comment">//			if err := ctx.Err(); err != context.DeadlineExceeded {</span></code></span>
<span class="codeline" id="line-174"><code><span class="comment">//				t.Fatalf("after timeout: ctx.Err() = %v, want DeadlineExceeded\n", err)</span></code></span>
<span class="codeline" id="line-175"><code><span class="comment">//			}</span></code></span>
<span class="codeline" id="line-176"><code><span class="comment">//		})</span></code></span>
<span class="codeline" id="line-177"><code><span class="comment">//	}</span></code></span>
<span class="codeline" id="line-178"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-179"><code><span class="comment">// # Example: HTTP 100 Continue</span></code></span>
<span class="codeline" id="line-180"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-181"><code><span class="comment">// This example demonstrates testing [http.Transport]'s 100 Continue handling.</span></code></span>
<span class="codeline" id="line-182"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-183"><code><span class="comment">// An HTTP client sending a request can include an "Expect: 100-continue" header</span></code></span>
<span class="codeline" id="line-184"><code><span class="comment">// to tell the server that the client has additional data to send.</span></code></span>
<span class="codeline" id="line-185"><code><span class="comment">// The server may then respond with an 100 Continue information response</span></code></span>
<span class="codeline" id="line-186"><code><span class="comment">// to request the data, or some other status to tell the client the data is not needed.</span></code></span>
<span class="codeline" id="line-187"><code><span class="comment">// For example, a client uploading a large file might use this feature to confirm</span></code></span>
<span class="codeline" id="line-188"><code><span class="comment">// that the server is willing to accept the file before sending it.</span></code></span>
<span class="codeline" id="line-189"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-190"><code><span class="comment">// This test confirms that when sending an "Expect: 100-continue" header</span></code></span>
<span class="codeline" id="line-191"><code><span class="comment">// the HTTP client does not send a request's content before the server requests it,</span></code></span>
<span class="codeline" id="line-192"><code><span class="comment">// and that it does send the content after receiving a 100 Continue response.</span></code></span>
<span class="codeline" id="line-193"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-194"><code><span class="comment">//	func TestHTTPTransport100Continue(t *testing.T) {</span></code></span>
<span class="codeline" id="line-195"><code><span class="comment">//		synctest.Test(t, func(*testing.T) {</span></code></span>
<span class="codeline" id="line-196"><code><span class="comment">//			// Create an in-process fake network connection.</span></code></span>
<span class="codeline" id="line-197"><code><span class="comment">//			// We cannot use a loopback network connection for this test,</span></code></span>
<span class="codeline" id="line-198"><code><span class="comment">//			// because goroutines blocked on network I/O prevent a synctest</span></code></span>
<span class="codeline" id="line-199"><code><span class="comment">//			// bubble from becoming idle.</span></code></span>
<span class="codeline" id="line-200"><code><span class="comment">//			srvConn, cliConn := net.Pipe()</span></code></span>
<span class="codeline" id="line-201"><code><span class="comment">//			defer cliConn.Close()</span></code></span>
<span class="codeline" id="line-202"><code><span class="comment">//			defer srvConn.Close()</span></code></span>
<span class="codeline" id="line-203"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-204"><code><span class="comment">//			tr := &amp;http.Transport{</span></code></span>
<span class="codeline" id="line-205"><code><span class="comment">//				// Use the fake network connection created above.</span></code></span>
<span class="codeline" id="line-206"><code><span class="comment">//				DialContext: func(ctx context.Context, network, address string) (net.Conn, error) {</span></code></span>
<span class="codeline" id="line-207"><code><span class="comment">//					return cliConn, nil</span></code></span>
<span class="codeline" id="line-208"><code><span class="comment">//				},</span></code></span>
<span class="codeline" id="line-209"><code><span class="comment">//				// Enable "Expect: 100-continue" handling.</span></code></span>
<span class="codeline" id="line-210"><code><span class="comment">//				ExpectContinueTimeout: 5 * time.Second,</span></code></span>
<span class="codeline" id="line-211"><code><span class="comment">//			}</span></code></span>
<span class="codeline" id="line-212"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-213"><code><span class="comment">//			// Send a request with the "Expect: 100-continue" header set.</span></code></span>
<span class="codeline" id="line-214"><code><span class="comment">//			// Send it in a new goroutine, since it won't complete until the end of the test.</span></code></span>
<span class="codeline" id="line-215"><code><span class="comment">//			body := "request body"</span></code></span>
<span class="codeline" id="line-216"><code><span class="comment">//			go func() {</span></code></span>
<span class="codeline" id="line-217"><code><span class="comment">//				req, _ := http.NewRequest("PUT", "http://test.tld/", strings.NewReader(body))</span></code></span>
<span class="codeline" id="line-218"><code><span class="comment">//				req.Header.Set("Expect", "100-continue")</span></code></span>
<span class="codeline" id="line-219"><code><span class="comment">//				resp, err := tr.RoundTrip(req)</span></code></span>
<span class="codeline" id="line-220"><code><span class="comment">//				if err != nil {</span></code></span>
<span class="codeline" id="line-221"><code><span class="comment">//					t.Errorf("RoundTrip: unexpected error %v\n", err)</span></code></span>
<span class="codeline" id="line-222"><code><span class="comment">//				} else {</span></code></span>
<span class="codeline" id="line-223"><code><span class="comment">//					resp.Body.Close()</span></code></span>
<span class="codeline" id="line-224"><code><span class="comment">//				}</span></code></span>
<span class="codeline" id="line-225"><code><span class="comment">//			}()</span></code></span>
<span class="codeline" id="line-226"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-227"><code><span class="comment">//			// Read the request headers sent by the client.</span></code></span>
<span class="codeline" id="line-228"><code><span class="comment">//			req, err := http.ReadRequest(bufio.NewReader(srvConn))</span></code></span>
<span class="codeline" id="line-229"><code><span class="comment">//			if err != nil {</span></code></span>
<span class="codeline" id="line-230"><code><span class="comment">//				t.Fatalf("ReadRequest: %v\n", err)</span></code></span>
<span class="codeline" id="line-231"><code><span class="comment">//			}</span></code></span>
<span class="codeline" id="line-232"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-233"><code><span class="comment">//			// Start a new goroutine copying the body sent by the client into a buffer.</span></code></span>
<span class="codeline" id="line-234"><code><span class="comment">//			// Wait for all goroutines in the bubble to block and verify that we haven't</span></code></span>
<span class="codeline" id="line-235"><code><span class="comment">//			// read anything from the client yet.</span></code></span>
<span class="codeline" id="line-236"><code><span class="comment">//			var gotBody bytes.Buffer</span></code></span>
<span class="codeline" id="line-237"><code><span class="comment">//			go io.Copy(&amp;gotBody, req.Body)</span></code></span>
<span class="codeline" id="line-238"><code><span class="comment">//			synctest.Wait()</span></code></span>
<span class="codeline" id="line-239"><code><span class="comment">//			if got, want := gotBody.String(), ""; got != want {</span></code></span>
<span class="codeline" id="line-240"><code><span class="comment">//				t.Fatalf("before sending 100 Continue, read body: %q, want %q\n", got, want)</span></code></span>
<span class="codeline" id="line-241"><code><span class="comment">//			}</span></code></span>
<span class="codeline" id="line-242"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-243"><code><span class="comment">//			// Write a "100 Continue" response to the client and verify that</span></code></span>
<span class="codeline" id="line-244"><code><span class="comment">//			// it sends the request body.</span></code></span>
<span class="codeline" id="line-245"><code><span class="comment">//			srvConn.Write([]byte("HTTP/1.1 100 Continue\r\n\r\n"))</span></code></span>
<span class="codeline" id="line-246"><code><span class="comment">//			synctest.Wait()</span></code></span>
<span class="codeline" id="line-247"><code><span class="comment">//			if got, want := gotBody.String(), body; got != want {</span></code></span>
<span class="codeline" id="line-248"><code><span class="comment">//				t.Fatalf("after sending 100 Continue, read body: %q, want %q\n", got, want)</span></code></span>
<span class="codeline" id="line-249"><code><span class="comment">//			}</span></code></span>
<span class="codeline" id="line-250"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-251"><code><span class="comment">//			// Finish up by sending the "200 OK" response to conclude the request.</span></code></span>
<span class="codeline" id="line-252"><code><span class="comment">//			srvConn.Write([]byte("HTTP/1.1 200 OK\r\n\r\n"))</span></code></span>
<span class="codeline" id="line-253"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-254"><code><span class="comment">//			// We started several goroutines during the test.</span></code></span>
<span class="codeline" id="line-255"><code><span class="comment">//			// The synctest.Test call will wait for all of them to exit before returning.</span></code></span>
<span class="codeline" id="line-256"><code><span class="comment">//		})</span></code></span>
<span class="codeline" id="line-257"><code><span class="comment">//	}</span></code></span></div><span class="codeline" id="line-258"><code><span class="keyword">package</span> synctest</code></span>
<span class="codeline" id="line-259"><code></code></span>
<span class="codeline" id="line-260"><code><span class="keyword">import</span> (</code></span>
<span class="codeline" id="line-261"><code>	<label for="i0"><span class="lit-string i0">"internal/synctest"</span></label></code></span>
<span class="codeline" id="line-262"><code>	<label for="i1"><span class="lit-string i1">"testing"</span></label></code></span>
<span class="codeline" id="line-263"><code>	<a href="../../../pkg/unsafe.html" class="ident i2">_</a> <label for="i2"><span class="lit-string i2">"unsafe"</span></label> <span class="comment">// for linkname</span></code></span>
<span class="codeline" id="line-264"><code>)</code></span>
<span class="codeline" id="line-265"><code></code></span>
<span class="codeline" id="line-266"><code><span class="comment">// Test executes f in a new bubble.</span></code></span>
<span class="codeline" id="line-267"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-268"><code><span class="comment">// Test waits for all goroutines in the bubble to exit before returning.</span></code></span>
<span class="codeline" id="line-269"><code><span class="comment">// If the goroutines in the bubble become deadlocked, the test fails.</span></code></span>
<span class="codeline" id="line-270"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-271"><code><span class="comment">// Test must not be called from within a bubble.</span></code></span>
<span class="codeline" id="line-272"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-273"><code><span class="comment">// The [*testing.T] provided to f has the following properties:</span></code></span>
<span class="codeline" id="line-274"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-275"><code><span class="comment">//   - T.Cleanup functions run inside the bubble,</span></code></span>
<span class="codeline" id="line-276"><code><span class="comment">//     immediately before Test returns.</span></code></span>
<span class="codeline" id="line-277"><code><span class="comment">//   - T.Context returns a [context.Context] with a Done channel</span></code></span>
<span class="codeline" id="line-278"><code><span class="comment">//     associated with the bubble.</span></code></span>
<span class="codeline" id="line-279"><code><span class="comment">//   - T.Run, T.Parallel, and T.Deadline must not be called.</span></code></span>
<span class="codeline" id="line-280"><code><span class="keyword">func</span> <label for="r0" class="ident"><a href="../../../pkg/testing/synctest.html#name-Test" class="ident">Test</a></label>(<label for="r1" class="ident">t</label> *<a href="../../../pkg/testing.html" class="ident i1">testing</a>.<a href="../testing.go.html#line-925" class="ident">T</a>, <label for="r2" class="ident">f</label> <span class="keyword">func</span>(*<a href="../../../pkg/testing.html" class="ident i1">testing</a>.<a href="../testing.go.html#line-925" class="ident">T</a>)) {</code></span>
<span class="codeline" id="line-281"><code>	<span class="keyword">var</span> <label for="r3" class="ident">ok</label> <a href="../../../pkg/builtin.html#name-bool" class="ident">bool</a></code></span>
<span class="codeline" id="line-282"><code>	<a href="../../../pkg/internal/synctest.html" class="ident i0">synctest</a>.<a href="../../internal/synctest/synctest.go.html#line-16" class="ident">Run</a>(<span class="keyword">func</span>() {</code></span>
<span class="codeline" id="line-283"><code>		<label for="r3" class="ident">ok</label> = <a href="#line-293" class="ident">testingSynctestTest</a>(<label for="r1" class="ident">t</label>, <label for="r2" class="ident">f</label>)</code></span>
<span class="codeline" id="line-284"><code>	})</code></span>
<span class="codeline" id="line-285"><code>	<span class="keyword">if</span> !<label for="r3" class="ident">ok</label> {</code></span>
<span class="codeline" id="line-286"><code>		<span class="comment">// Fail the test outside the bubble,</span></code></span>
<span class="codeline" id="line-287"><code><span class="comment">		// so test durations get set using real time.</span></code></span>
<span class="codeline" id="line-288"><code>		<label for="r1" class="ident">t</label>.<a href="../testing.go.html#line-987" class="ident">FailNow</a>()</code></span>
<span class="codeline" id="line-289"><code>	}</code></span>
<span class="codeline" id="line-290"><code>}</code></span>
<span class="codeline" id="line-291"><code></code></span>
<span class="codeline" id="line-292"><code><span class="comment">//go:linkname testingSynctestTest testing/synctest.testingSynctestTest</span></code></span>
<span class="codeline" id="line-293"><code><span class="keyword">func</span> <label for="r4" class="ident"><a href="../../../pkg/testing/synctest.html#name-testingSynctestTest" class="ident">testingSynctestTest</a></label>(<label for="r5" class="ident">t</label> *<a href="../../../pkg/testing.html" class="ident i1">testing</a>.<a href="../testing.go.html#line-925" class="ident">T</a>, <label for="r6" class="ident">f</label> <span class="keyword">func</span>(*<a href="../../../pkg/testing.html" class="ident i1">testing</a>.<a href="../testing.go.html#line-925" class="ident">T</a>)) <a href="../../../pkg/builtin.html#name-bool" class="ident">bool</a></code></span>
<span class="codeline" id="line-294"><code></code></span>
<span class="codeline" id="line-295"><code><span class="comment">// Wait blocks until every goroutine within the current bubble,</span></code></span>
<span class="codeline" id="line-296"><code><span class="comment">// other than the current goroutine, is durably blocked.</span></code></span>
<span class="codeline" id="line-297"><code><span class="comment">//</span></code></span>
<span class="codeline" id="line-298"><code><span class="comment">// Wait must not be called from outside a bubble.</span></code></span>
<span class="codeline" id="line-299"><code><span class="comment">// Wait must not be called concurrently by multiple goroutines</span></code></span>
<span class="codeline" id="line-300"><code><span class="comment">// in the same bubble.</span></code></span>
<span class="codeline" id="line-301"><code><span class="keyword">func</span> <label for="r7" class="ident"><a href="../../../pkg/testing/synctest.html#name-Wait" class="ident">Wait</a></label>() {</code></span>
<span class="codeline" id="line-302"><code>	<a href="../../../pkg/internal/synctest.html" class="ident i0">synctest</a>.<a href="../../internal/synctest/synctest.go.html#line-19" class="ident">Wait</a>()</code></span>
<span class="codeline" id="line-303"><code>}</code></span>
</pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.7.6</i>. (GOOS=linux GOARCH=amd64)</pre>