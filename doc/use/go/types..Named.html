<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>References: go/types.Named</title>
<link href="../../css/auto-v0.7.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.7.6.js"></script>
<body onload="onPageLoad()"><div>

<pre><code><span style="font-size:x-large;">type <b><a href="../../pkg/go/types.html">go/types</a>.<a href="../../src/go/types/named.go.html#line-109">Named</a></b></span>

<span class="title">126 uses</span>

	go/types (current package)
		<a href="../../src/go/types/alias.go.html#line-137">alias.go#L137</a>: func asNamed(t Type) *<b>Named</b> {
		<a href="../../src/go/types/alias.go.html#line-138" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-138">#L138</a>: 	n, _ := Unalias(t).(*<b>Named</b>)
		<a href="../../src/go/types/alias.go.html#line-165" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-165">#L165</a>: func (check *Checker) newAliasInstance(pos token.Pos, orig *Alias, targs []Type, expanding *<b>Named</b>, ctxt *Context) *Alias {
		<a href="../../src/go/types/builtins.go.html#line-924">builtins.go#L924</a>: func hasVarSize(t Type, seen map[*<b>Named</b>]bool) (varSized bool) {
		<a href="../../src/go/types/builtins.go.html#line-933" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-933">#L933</a>: 			seen = make(map[*<b>Named</b>]bool)
		<a href="../../src/go/types/builtins.go.html#line-952" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-952">#L952</a>: 	case *<b>Named</b>, *Union:
		<a href="../../src/go/types/decl.go.html#line-804">decl.go#L804</a>: func (check *Checker) checkFieldUniqueness(base *<b>Named</b>) {
		<a href="../../src/go/types/expr.go.html#line-972">expr.go#L972</a>: 	case *Alias, *<b>Named</b>:
		<a href="../../src/go/types/infer.go.html#line-625">infer.go#L625</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/infer.go.html#line-777" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-777">#L777</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/instantiate.go.html#line-91">instantiate.go#L91</a>: func (check *Checker) instance(pos token.Pos, orig genericType, targs []Type, expanding *<b>Named</b>, ctxt *Context) (res Type) {
		<a href="../../src/go/types/instantiate.go.html#line-132" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-132">#L132</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/interface.go.html#line-39">interface.go#L39</a>: func NewInterface(methods []*Func, embeddeds []*<b>Named</b>) *Interface {
		<a href="../../src/go/types/interface.go.html#line-107" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-107">#L107</a>: func (t *Interface) Embedded(i int) *<b>Named</b> { return asNamed(t.embeddeds[i]) }
		<a href="../../src/go/types/iter.go.html#line-60">iter.go#L60</a>: func (t *<b>Named</b>) Methods() iter.Seq[*Func] {
		<a href="../../src/go/types/lookup.go.html#line-283">lookup.go#L283</a>: 	buf [3]*<b>Named</b>
		<a href="../../src/go/types/lookup.go.html#line-284" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-284">#L284</a>: 	m   map[*<b>Named</b>][]*<b>Named</b>
		<a href="../../src/go/types/lookup.go.html#line-287" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-287">#L287</a>: func (l *instanceLookup) lookup(inst *<b>Named</b>) *<b>Named</b> {
		<a href="../../src/go/types/lookup.go.html#line-301" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-301">#L301</a>: func (l *instanceLookup) add(inst *<b>Named</b>) {
		<a href="../../src/go/types/lookup.go.html#line-309" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-309">#L309</a>: 		l.m = make(map[*<b>Named</b>][]*<b>Named</b>)
		<a href="../../src/go/types/mono.go.html#line-156">mono.go#L156</a>: 		case *<b>Named</b>:
		<a href="../../src/go/types/mono.go.html#line-222" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-222">#L222</a>: 		case *<b>Named</b>:
		<a href="../../src/go/types/mono.go.html#line-269" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-269">#L269</a>: func (w *monoGraph) localNamedVertex(pkg *Package, named *<b>Named</b>) int {
		<a href="../../src/go/types/named.go.html#line-109">named.go#L109</a>: type <b>Named</b> struct {
		<a href="../../src/go/types/named.go.html#line-134" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-134">#L134</a>: 	loader func(*<b>Named</b>) (tparams []*TypeParam, underlying Type, methods []*Func)
		<a href="../../src/go/types/named.go.html#line-140" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-140">#L140</a>: 	orig            *<b>Named</b>    // original, uninstantiated type
		<a href="../../src/go/types/named.go.html#line-158" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-158">#L158</a>: func NewNamed(obj *TypeName, underlying Type, methods []*Func) *<b>Named</b> {
		<a href="../../src/go/types/named.go.html#line-172" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-172">#L172</a>: func (n *<b>Named</b>) resolve() *<b>Named</b> {
		<a href="../../src/go/types/named.go.html#line-232" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-232">#L232</a>: func (n *<b>Named</b>) state() namedState {
		<a href="../../src/go/types/named.go.html#line-238" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-238">#L238</a>: func (n *<b>Named</b>) setState(state namedState) {
		<a href="../../src/go/types/named.go.html#line-243" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-243">#L243</a>: func (check *Checker) newNamed(obj *TypeName, underlying Type, methods []*Func) *<b>Named</b> {
		<a href="../../src/go/types/named.go.html#line-244" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-244">#L244</a>: 	typ := &amp;<b>Named</b>{check: check, obj: obj, fromRHS: underlying, underlying: underlying, methods: methods}
		<a href="../../src/go/types/named.go.html#line-261" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-261">#L261</a>: func (check *Checker) newNamedInstance(pos token.Pos, orig *<b>Named</b>, targs []Type, expanding *<b>Named</b>) *<b>Named</b> {
		<a href="../../src/go/types/named.go.html#line-275" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-275">#L275</a>: 	typ := &amp;<b>Named</b>{check: check, obj: obj, inst: inst}
		<a href="../../src/go/types/named.go.html#line-284" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-284">#L284</a>: func (t *<b>Named</b>) cleanup() {
		<a href="../../src/go/types/named.go.html#line-299" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-299">#L299</a>: 	case *<b>Named</b>, *Alias:
		<a href="../../src/go/types/named.go.html#line-307" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-307">#L307</a>: func (t *<b>Named</b>) Obj() *TypeName {
		<a href="../../src/go/types/named.go.html#line-316" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-316">#L316</a>: func (t *<b>Named</b>) Origin() *<b>Named</b> {
		<a href="../../src/go/types/named.go.html#line-325" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-325">#L325</a>: func (t *<b>Named</b>) TypeParams() *TypeParamList { return t.resolve().tparams }
		<a href="../../src/go/types/named.go.html#line-329" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-329">#L329</a>: func (t *<b>Named</b>) SetTypeParams(tparams []*TypeParam) {
		<a href="../../src/go/types/named.go.html#line-335" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-335">#L335</a>: func (t *<b>Named</b>) TypeArgs() *TypeList {
		<a href="../../src/go/types/named.go.html#line-343" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-343">#L343</a>: func (t *<b>Named</b>) NumMethods() int {
		<a href="../../src/go/types/named.go.html#line-358" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-358">#L358</a>: func (t *<b>Named</b>) Method(i int) *Func {
		<a href="../../src/go/types/named.go.html#line-394" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-394">#L394</a>: func (t *<b>Named</b>) expandMethod(i int) *Func {
		<a href="../../src/go/types/named.go.html#line-453" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-453">#L453</a>: func (t *<b>Named</b>) SetUnderlying(underlying Type) {
		<a href="../../src/go/types/named.go.html#line-470" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-470">#L470</a>: func (t *<b>Named</b>) AddMethod(m *Func) {
		<a href="../../src/go/types/named.go.html#line-482" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-482">#L482</a>: func (t *<b>Named</b>) methodIndex(name string, foldCase bool) int {
		<a href="../../src/go/types/named.go.html#line-507" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-507">#L507</a>: func (t *<b>Named</b>) Underlying() Type {
		<a href="../../src/go/types/named.go.html#line-512" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-512">#L512</a>: func (t *<b>Named</b>) String() string { return TypeString(t, nil) }
		<a href="../../src/go/types/named.go.html#line-538" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-538">#L538</a>: func (n0 *<b>Named</b>) under() Type {
		<a href="../../src/go/types/named.go.html#line-544" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-544">#L544</a>: 	var n1 *<b>Named</b>
		<a href="../../src/go/types/named.go.html#line-553" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-553">#L553</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/named.go.html#line-567" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-567">#L567</a>: 	seen := make(map[*<b>Named</b>]int) // types that need their underlying type resolved
		<a href="../../src/go/types/named.go.html#line-588" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-588">#L588</a>: 		case *<b>Named</b>:
		<a href="../../src/go/types/named.go.html#line-608" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-608">#L608</a>: func (n *<b>Named</b>) lookupMethod(pkg *Package, name string, foldCase bool) (int, *Func) {
		<a href="../../src/go/types/named.go.html#line-632" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-632">#L632</a>: func (n *<b>Named</b>) expandUnderlying() Type {
		<a href="../../src/go/types/object.go.html#line-299">object.go#L299</a>: func _NewTypeNameLazy(pos token.Pos, pkg *Package, name string, load func(named *<b>Named</b>) (tparams []*TypeParam, underlying Type, methods []*Func)) *TypeName {
		<a href="../../src/go/types/object.go.html#line-324" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-324">#L324</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/operand.go.html#line-197">operand.go#L197</a>: 				case *Alias, *<b>Named</b>:
		<a href="../../src/go/types/predicates.go.html#line-72">predicates.go#L72</a>: 	case *Basic, *<b>Named</b>, *TypeParam:
		<a href="../../src/go/types/predicates.go.html#line-83" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-83">#L83</a>: 	case *<b>Named</b>, *TypeParam:
		<a href="../../src/go/types/predicates.go.html#line-471" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-471">#L471</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/predicates.go.html#line-506" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-506">#L506</a>: func identicalOrigin(x, y *<b>Named</b>) bool {
		<a href="../../src/go/types/signature.go.html#line-199">signature.go#L199</a>: 		var baseType *<b>Named</b> // nil if not valid
		<a href="../../src/go/types/signature.go.html#line-203" class="path-duplicate">signature.go</a><a href="../../src/go/types/signature.go.html#line-203">#L203</a>: 			case *<b>Named</b>:
		<a href="../../src/go/types/signature.go.html#line-436" class="path-duplicate">signature.go</a><a href="../../src/go/types/signature.go.html#line-436">#L436</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/subst.go.html#line-58">subst.go#L58</a>: func (check *Checker) subst(pos token.Pos, typ Type, smap substMap, expanding *<b>Named</b>, ctxt *Context) Type {
		<a href="../../src/go/types/subst.go.html#line-88" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-88">#L88</a>: 	expanding *<b>Named</b>   // if non-nil, the instance that is being expanded
		<a href="../../src/go/types/subst.go.html#line-241" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-241">#L241</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/typestring.go.html#line-294">typestring.go#L294</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/typexpr.go.html#line-425">typexpr.go#L425</a>: 		case *<b>Named</b>:
		<a href="../../src/go/types/unify.go.html#line-735">unify.go#L735</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/validtype.go.html#line-16">validtype.go#L16</a>: func (check *Checker) validType(typ *<b>Named</b>) {
		<a href="../../src/go/types/validtype.go.html#line-30" class="path-duplicate">validtype.go</a><a href="../../src/go/types/validtype.go.html#line-30">#L30</a>: func (check *Checker) validType0(pos token.Pos, typ Type, nest, path []*<b>Named</b>) bool {
		<a href="../../src/go/types/validtype.go.html#line-34" class="path-duplicate">validtype.go</a><a href="../../src/go/types/validtype.go.html#line-34">#L34</a>: 		if t, _ := typ.(*<b>Named</b>); t != nil &amp;&amp; t.obj != nil /* obj should always exist but be conservative */ {
		<a href="../../src/go/types/validtype.go.html#line-76" class="path-duplicate">validtype.go</a><a href="../../src/go/types/validtype.go.html#line-76">#L76</a>: 	case *<b>Named</b>:
		<a href="../../src/go/types/validtype.go.html#line-195" class="path-duplicate">validtype.go</a><a href="../../src/go/types/validtype.go.html#line-195">#L195</a>: func makeObjList(tlist []*<b>Named</b>) []Object {

	<a href="../../pkg/golang.org/x/exp/apidiff.html">golang.org/x/exp/apidiff</a>
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-159">apidiff.go#L159</a>: 			if oldn, ok := tn.Type().(*types.<b>Named</b>); ok {
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-207" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-207">#L207</a>: 		ot1 := k1.(*types.<b>Named</b>)
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-223" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-223">#L223</a>: 			ot2 := k2.(*types.<b>Named</b>)
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-35">compatibility.go#L35</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-261" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-261">#L261</a>: func (d *differ) checkCompatibleDefined(otn *types.TypeName, old *types.<b>Named</b>, new types.Type) {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-350" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-350">#L350</a>: func receiverNamedType(method types.Object) *types.<b>Named</b> {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-353" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-353">#L353</a>: 		return t.Elem().(*types.<b>Named</b>)
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-354" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-354">#L354</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-123">correspondence.go#L123</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-146" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-146">#L146</a>: 		if on, ok := of.Type().(*types.<b>Named</b>); ok {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-147" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-147">#L147</a>: 			nn := nf.Type().(*types.<b>Named</b>)
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-161" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-161">#L161</a>: func (d *differ) establishCorrespondence(old *types.<b>Named</b>, new types.Type) bool {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-191" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-191">#L191</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-305" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-305">#L305</a>: func isInstantiated(t *types.<b>Named</b>) bool {

	<a href="../../pkg/golang.org/x/tools/go/types/objectpath.html">golang.org/x/tools/go/types/objectpath</a>
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-297">objectpath.go#L297</a>: 		} else if named, ok := T.(*types.<b>Named</b>); ok {
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-323" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-323">#L323</a>: 		if T, ok := types.Unalias(o.Type()).(*types.<b>Named</b>); ok {
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-472" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-472">#L472</a>: 	case *types.Basic, *types.<b>Named</b>:
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-689" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-689">#L689</a>: 			named, ok := t.(*types.<b>Named</b>)
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-764" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-764">#L764</a>: 			case *types.<b>Named</b>:

	<a href="../../pkg/golang.org/x/tools/go/types/typeutil.html">golang.org/x/tools/go/types/typeutil</a>
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-305">map.go#L305</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-468" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-468">#L468</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-19">methodsetcache.go#L19</a>: 	named  map[*types.<b>Named</b>]struct{ value, pointer *types.MethodSet } // method sets for named N and *N
		<a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-36" class="path-duplicate">methodsetcache.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-36">#L36</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-40" class="path-duplicate">methodsetcache.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-40">#L40</a>: 		if N, ok := types.Unalias(T.Elem()).(*types.<b>Named</b>); ok {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-58" class="path-duplicate">methodsetcache.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-58">#L58</a>: func (cache *MethodSetCache) lookupNamed(named *types.<b>Named</b>) struct{ value, pointer *types.MethodSet } {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-60" class="path-duplicate">methodsetcache.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-60">#L60</a>: 		cache.named = make(map[*types.<b>Named</b>]struct{ value, pointer *types.MethodSet })

	<a href="../../pkg/golang.org/x/tools/internal/gcimporter.html">golang.org/x/tools/internal/gcimporter</a>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-796">iexport.go#L796</a>: 		named, ok := t.(*types.<b>Named</b>)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1016" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1016">#L1016</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1121" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1121">#L1121</a>: 			if named, _ := types.Unalias(ft).(*types.<b>Named</b>); named != nil {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-514">iimport.go#L514</a>: func (p *iimporter) typAt(off uint64, base *types.<b>Named</b>) types.Type {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-539" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-539">#L539</a>: func canReuse(def *types.<b>Named</b>, rhs types.Type) bool {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-876" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-876">#L876</a>: func (r *importReader) doType(base *types.<b>Named</b>) (res types.Type) {

	<a href="../../pkg/golang.org/x/tools/internal/typeparams.html">golang.org/x/tools/internal/typeparams</a>
		<a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-115">coretype.go#L115</a>: 	if named, ok := typ.(*types.<b>Named</b>); ok {
		<a href="../../src/golang.org/x/tools/internal/typeparams/free.go.html#line-111">free.go#L111</a>: 	case *types.<b>Named</b>:

	<a href="../../pkg/golang.org/x/tools/internal/typesinternal.html">golang.org/x/tools/internal/typesinternal</a>
		<a href="../../src/golang.org/x/tools/internal/typesinternal/element.go.html#line-98">element.go#L98</a>: 		case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/tools/internal/typesinternal/recv.go.html#line-17">recv.go#L17</a>: func ReceiverNamed(recv *types.Var) (isPtr bool, named *types.<b>Named</b>) {
		<a href="../../src/golang.org/x/tools/internal/typesinternal/recv.go.html#line-23" class="path-duplicate">recv.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/recv.go.html#line-23">#L23</a>: 	named, _ = types.Unalias(t).(*types.<b>Named</b>)
		<a href="../../src/golang.org/x/tools/internal/typesinternal/types.go.html#line-87">types.go#L87</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/tools/internal/typesinternal/types.go.html#line-123" class="path-duplicate">types.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/types.go.html#line-123">#L123</a>: 	_ NamedOrAlias = (*types.<b>Named</b>)(nil)
		<a href="../../src/golang.org/x/tools/internal/typesinternal/types.go.html#line-132" class="path-duplicate">types.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/types.go.html#line-132">#L132</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/tools/internal/typesinternal/zerovalue.go.html#line-63">zerovalue.go#L63</a>: 	case *types.<b>Named</b>:
		<a href="../../src/golang.org/x/tools/internal/typesinternal/zerovalue.go.html#line-156" class="path-duplicate">zerovalue.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/zerovalue.go.html#line-156">#L156</a>: 	case *types.<b>Named</b>:
</code></pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.7.6</i>. (GOOS=linux GOARCH=amd64)</pre>