<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>References: go/types.Type</title>
<link href="../../css/auto-v0.7.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.7.6.js"></script>
<body onload="onPageLoad()"><div>

<pre><code><span style="font-size:x-large;">type <b><a href="../../pkg/go/types.html">go/types</a>.<a href="../../src/go/types/type.go.html#line-9">Type</a></b></span>

<span class="title">538 uses</span>

	go/types (current package)
		<a href="../../src/go/types/alias.go.html#line-51">alias.go#L51</a>: 	fromRHS <b>Type</b>           // RHS of type alias declaration; may be an alias
		<a href="../../src/go/types/alias.go.html#line-52" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-52">#L52</a>: 	actual  <b>Type</b>           // actual (aliased) type; never an alias
		<a href="../../src/go/types/alias.go.html#line-57" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-57">#L57</a>: func NewAlias(obj *TypeName, rhs <b>Type</b>) *Alias {
		<a href="../../src/go/types/alias.go.html#line-75" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-75">#L75</a>: func (a *Alias) Underlying() <b>Type</b> { return unalias(a).Underlying() }
		<a href="../../src/go/types/alias.go.html#line-98" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-98">#L98</a>: func (a *Alias) Rhs() <b>Type</b> { return a.fromRHS }
		<a href="../../src/go/types/alias.go.html#line-104" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-104">#L104</a>: func Unalias(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/alias.go.html#line-111" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-111">#L111</a>: func unalias(a0 *Alias) <b>Type</b> {
		<a href="../../src/go/types/alias.go.html#line-115" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-115">#L115</a>: 	var t <b>Type</b>
		<a href="../../src/go/types/alias.go.html#line-137" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-137">#L137</a>: func asNamed(t <b>Type</b>) *Named {
		<a href="../../src/go/types/alias.go.html#line-144" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-144">#L144</a>: func (check *Checker) newAlias(obj *TypeName, rhs <b>Type</b>) *Alias {
		<a href="../../src/go/types/alias.go.html#line-165" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-165">#L165</a>: func (check *Checker) newAliasInstance(pos token.Pos, orig *Alias, targs []<b>Type</b>, expanding *Named, ctxt *Context) *Alias {
		<a href="../../src/go/types/api.go.html#line-338">api.go#L338</a>: func (info *Info) TypeOf(e ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/api.go.html#line-385" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-385">#L385</a>: 	Type  <b>Type</b>
		<a href="../../src/go/types/api.go.html#line-447" class="path-duplicate">api.go</a><a href="../../src/go/types/api.go.html#line-447">#L447</a>: 	Type     <b>Type</b>
		<a href="../../src/go/types/api_predicates.go.html#line-19">api_predicates.go#L19</a>: func AssertableTo(V *Interface, T <b>Type</b>) bool {
		<a href="../../src/go/types/api_predicates.go.html#line-33" class="path-duplicate">api_predicates.go</a><a href="../../src/go/types/api_predicates.go.html#line-33">#L33</a>: func AssignableTo(V, T <b>Type</b>) bool {
		<a href="../../src/go/types/api_predicates.go.html#line-44" class="path-duplicate">api_predicates.go</a><a href="../../src/go/types/api_predicates.go.html#line-44">#L44</a>: func ConvertibleTo(V, T <b>Type</b>) bool {
		<a href="../../src/go/types/api_predicates.go.html#line-53" class="path-duplicate">api_predicates.go</a><a href="../../src/go/types/api_predicates.go.html#line-53">#L53</a>: func Implements(V <b>Type</b>, T *Interface) bool {
		<a href="../../src/go/types/api_predicates.go.html#line-70" class="path-duplicate">api_predicates.go</a><a href="../../src/go/types/api_predicates.go.html#line-70">#L70</a>: func Satisfies(V <b>Type</b>, T *Interface) bool {
		<a href="../../src/go/types/api_predicates.go.html#line-88" class="path-duplicate">api_predicates.go</a><a href="../../src/go/types/api_predicates.go.html#line-88">#L88</a>: func Identical(x, y <b>Type</b>) bool {
		<a href="../../src/go/types/api_predicates.go.html#line-95" class="path-duplicate">api_predicates.go</a><a href="../../src/go/types/api_predicates.go.html#line-95">#L95</a>: func IdenticalIgnoreTags(x, y <b>Type</b>) bool {
		<a href="../../src/go/types/array.go.html#line-13">array.go#L13</a>: 	elem <b>Type</b>
		<a href="../../src/go/types/array.go.html#line-18" class="path-duplicate">array.go</a><a href="../../src/go/types/array.go.html#line-18">#L18</a>: func NewArray(elem <b>Type</b>, len int64) *Array { return &amp;Array{len: len, elem: elem} }
		<a href="../../src/go/types/array.go.html#line-25" class="path-duplicate">array.go</a><a href="../../src/go/types/array.go.html#line-25">#L25</a>: func (a *Array) Elem() <b>Type</b> { return a.elem }
		<a href="../../src/go/types/array.go.html#line-27" class="path-duplicate">array.go</a><a href="../../src/go/types/array.go.html#line-27">#L27</a>: func (a *Array) Underlying() <b>Type</b> { return a }
		<a href="../../src/go/types/assignments.go.html#line-24">assignments.go#L24</a>: func (check *Checker) assignment(x *operand, T <b>Type</b>, context string) {
		<a href="../../src/go/types/assignments.go.html#line-188" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-188">#L188</a>: func (check *Checker) lhsVar(lhs ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/assignments.go.html#line-282" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-282">#L282</a>: func operandTypes(list []*operand) (res []<b>Type</b>) {
		<a href="../../src/go/types/assignments.go.html#line-290" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-290">#L290</a>: func varTypes(list []*Var) (res []<b>Type</b>) {
		<a href="../../src/go/types/assignments.go.html#line-304" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-304">#L304</a>: func (check *Checker) typesSummary(list []<b>Type</b>, variadic, hasDots bool) string {
		<a href="../../src/go/types/badlinkname.go.html#line-20">badlinkname.go#L20</a>: func badlinkname_Checker_infer(*Checker, positioner, []*TypeParam, []<b>Type</b>, *Tuple, []*operand, bool, *error_) []<b>Type</b>
		<a href="../../src/go/types/basic.go.html#line-84">basic.go#L84</a>: func (b *Basic) Underlying() <b>Type</b> { return b }
		<a href="../../src/go/types/builtins.go.html#line-94">builtins.go#L94</a>: 		var T <b>Type</b>
		<a href="../../src/go/types/builtins.go.html#line-190" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-190">#L190</a>: 			if underIs(x.typ, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/builtins.go.html#line-234" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-234">#L234</a>: 		if !underIs(x.typ, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/builtins.go.html#line-252" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-252">#L252</a>: 		if !underIs(x.typ, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/builtins.go.html#line-328" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-328">#L328</a>: 		f := func(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/builtins.go.html#line-393" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-393">#L393</a>: 		var key <b>Type</b>
		<a href="../../src/go/types/builtins.go.html#line-394" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-394">#L394</a>: 		if !underIs(map_, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/builtins.go.html#line-448" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-448">#L448</a>: 		f := func(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/builtins.go.html#line-517" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-517">#L517</a>: 		types := []<b>Type</b>{T}
		<a href="../../src/go/types/builtins.go.html#line-594" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-594">#L594</a>: 			types := make([]<b>Type</b>, nargs)
		<a href="../../src/go/types/builtins.go.html#line-643" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-643">#L643</a>: 		var params []<b>Type</b>
		<a href="../../src/go/types/builtins.go.html#line-645" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-645">#L645</a>: 			params = make([]<b>Type</b>, nargs)
		<a href="../../src/go/types/builtins.go.html#line-924" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-924">#L924</a>: func hasVarSize(t <b>Type</b>, seen map[*Named]bool) (varSized bool) {
		<a href="../../src/go/types/builtins.go.html#line-965" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-965">#L965</a>: func (check *Checker) applyTypeFunc(f func(<b>Type</b>) <b>Type</b>, x *operand, id builtinId) <b>Type</b> {
		<a href="../../src/go/types/builtins.go.html#line-1004" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-1004">#L1004</a>: 		ptyp := check.newTypeParam(tpar, NewInterfaceType(nil, []<b>Type</b>{NewUnion(terms)})) // assigns type to tpar as a side-effect
		<a href="../../src/go/types/builtins.go.html#line-1015" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-1015">#L1015</a>: func makeSig(res <b>Type</b>, args ...<b>Type</b>) *Signature {
		<a href="../../src/go/types/builtins.go.html#line-1031" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-1031">#L1031</a>: func arrayPtrDeref(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/call.go.html#line-35">call.go#L35</a>: func (check *Checker) funcInst(T *target, pos token.Pos, x *operand, ix *indexedExpr, infer bool) ([]<b>Type</b>, []ast.Expr) {
		<a href="../../src/go/types/call.go.html#line-48" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-48">#L48</a>: 	var targs []<b>Type</b>
		<a href="../../src/go/types/call.go.html#line-133" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-133">#L133</a>: func (check *Checker) instantiateSignature(pos token.Pos, expr ast.Expr, typ *Signature, targs []<b>Type</b>, xlist []ast.Expr) (res *Signature) {
		<a href="../../src/go/types/call.go.html#line-262" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-262">#L262</a>: 	var targs []<b>Type</b>
		<a href="../../src/go/types/call.go.html#line-359" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-359">#L359</a>: func (check *Checker) genericExprList(elist []ast.Expr) (resList []*operand, targsList [][]<b>Type</b>, xlistList [][]ast.Expr) {
		<a href="../../src/go/types/call.go.html#line-393" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-393">#L393</a>: 				targsList = [][]<b>Type</b>{targs}
		<a href="../../src/go/types/call.go.html#line-421" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-421">#L421</a>: 		targsList = make([][]<b>Type</b>, n)
		<a href="../../src/go/types/call.go.html#line-462" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-462">#L462</a>: func (check *Checker) arguments(call *ast.CallExpr, sig *Signature, targs []<b>Type</b>, xlist []ast.Expr, args []*operand, atargs [][]<b>Type</b>, atxlist [][]ast.Expr) (rsig *Signature) {
		<a href="../../src/go/types/call.go.html#line-558" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-558">#L558</a>: 		var tmp <b>Type</b>
		<a href="../../src/go/types/chan.go.html#line-13">chan.go#L13</a>: 	elem <b>Type</b>
		<a href="../../src/go/types/chan.go.html#line-27" class="path-duplicate">chan.go</a><a href="../../src/go/types/chan.go.html#line-27">#L27</a>: func NewChan(dir ChanDir, elem <b>Type</b>) *Chan {
		<a href="../../src/go/types/chan.go.html#line-35" class="path-duplicate">chan.go</a><a href="../../src/go/types/chan.go.html#line-35">#L35</a>: func (c *Chan) Elem() <b>Type</b> { return c.elem }
		<a href="../../src/go/types/chan.go.html#line-37" class="path-duplicate">chan.go</a><a href="../../src/go/types/chan.go.html#line-37">#L37</a>: func (c *Chan) Underlying() <b>Type</b> { return c }
		<a href="../../src/go/types/check.go.html#line-232">check.go#L232</a>: func (check *Checker) validAlias(alias *TypeName, typ <b>Type</b>) {
		<a href="../../src/go/types/check.go.html#line-572" class="path-duplicate">check.go</a><a href="../../src/go/types/check.go.html#line-572">#L572</a>: func (check *Checker) recordTypeAndValueInSyntax(x ast.Expr, mode operandMode, typ <b>Type</b>, val constant.Value) {
		<a href="../../src/go/types/check.go.html#line-578" class="path-duplicate">check.go</a><a href="../../src/go/types/check.go.html#line-578">#L578</a>: func (check *Checker) recordCommaOkTypesInSyntax(x ast.Expr, t0, t1 <b>Type</b>) {
		<a href="../../src/go/types/const.go.html#line-76">const.go#L76</a>: 	sizeof := func(T <b>Type</b>) int64 {
		<a href="../../src/go/types/const.go.html#line-277" class="path-duplicate">const.go</a><a href="../../src/go/types/const.go.html#line-277">#L277</a>: func (check *Checker) invalidConversion(code Code, x *operand, target <b>Type</b>) {
		<a href="../../src/go/types/const.go.html#line-289" class="path-duplicate">const.go</a><a href="../../src/go/types/const.go.html#line-289">#L289</a>: func (check *Checker) convertUntyped(x *operand, target <b>Type</b>) {
		<a href="../../src/go/types/context.go.html#line-48">context.go#L48</a>: 	originIDs map[<b>Type</b>]int           // origin type -&gt; unique ID
		<a href="../../src/go/types/context.go.html#line-52" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-52">#L52</a>: 	orig     <b>Type</b>
		<a href="../../src/go/types/context.go.html#line-53" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-53">#L53</a>: 	targs    []<b>Type</b>
		<a href="../../src/go/types/context.go.html#line-54" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-54">#L54</a>: 	instance <b>Type</b> // = orig[targs]
		<a href="../../src/go/types/context.go.html#line-61" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-61">#L61</a>: 		originIDs: make(map[<b>Type</b>]int),
		<a href="../../src/go/types/context.go.html#line-68" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-68">#L68</a>: func (ctxt *Context) instanceHash(orig <b>Type</b>, targs []<b>Type</b>) string {
		<a href="../../src/go/types/context.go.html#line-90" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-90">#L90</a>: func (ctxt *Context) lookup(h string, orig <b>Type</b>, targs []<b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/context.go.html#line-111" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-111">#L111</a>: func (ctxt *Context) update(h string, orig <b>Type</b>, targs []<b>Type</b>, inst <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/context.go.html#line-137" class="path-duplicate">context.go</a><a href="../../src/go/types/context.go.html#line-137">#L137</a>: func (ctxt *Context) getID(t <b>Type</b>) int {
		<a href="../../src/go/types/conversions.go.html#line-20">conversions.go#L20</a>: func (check *Checker) conversion(x *operand, T <b>Type</b>) {
		<a href="../../src/go/types/conversions.go.html#line-23" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-23">#L23</a>: 	constConvertibleTo := func(T <b>Type</b>, val *constant.Value) bool {
		<a href="../../src/go/types/conversions.go.html#line-62" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-62">#L62</a>: 		ok = underIs(T, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/conversions.go.html#line-139" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-139">#L139</a>: func (x *operand) convertibleTo(check *Checker, T <b>Type</b>, cause *string) bool {
		<a href="../../src/go/types/conversions.go.html#line-297" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-297">#L297</a>: func isUintptr(typ <b>Type</b>) bool {
		<a href="../../src/go/types/conversions.go.html#line-302" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-302">#L302</a>: func isUnsafePointer(typ <b>Type</b>) bool {
		<a href="../../src/go/types/conversions.go.html#line-307" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-307">#L307</a>: func isPointer(typ <b>Type</b>) bool {
		<a href="../../src/go/types/conversions.go.html#line-312" class="path-duplicate">conversions.go</a><a href="../../src/go/types/conversions.go.html#line-312">#L312</a>: func isBytesOrRunes(typ <b>Type</b>) bool {
		<a href="../../src/go/types/decl.go.html#line-532">decl.go#L532</a>: func (check *Checker) isImportedConstraint(typ <b>Type</b>) bool {
		<a href="../../src/go/types/decl.go.html#line-547" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-547">#L547</a>: 	var rhs <b>Type</b>
		<a href="../../src/go/types/decl.go.html#line-688" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-688">#L688</a>: 		var bound <b>Type</b>
		<a href="../../src/go/types/decl.go.html#line-711" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-711">#L711</a>: func (check *Checker) bound(x ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/errsupport.go.html#line-15">errsupport.go#L15</a>: func (check *Checker) lookupError(typ <b>Type</b>, sel string, obj Object, structLit bool) string {
		<a href="../../src/go/types/expr.go.html#line-59">expr.go#L59</a>: type opPredicates map[token.Token]func(<b>Type</b>) bool
		<a href="../../src/go/types/expr.go.html#line-230" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-230">#L230</a>: func (check *Checker) updateExprType(x ast.Expr, typ <b>Type</b>, final bool) {
		<a href="../../src/go/types/expr.go.html#line-357" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-357">#L357</a>: func (check *Checker) implicitTypeAndValue(x *operand, target <b>Type</b>) (<b>Type</b>, constant.Value, Code) {
		<a href="../../src/go/types/expr.go.html#line-412" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-412">#L412</a>: 			if !underIs(target, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/expr.go.html#line-577" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-577">#L577</a>: func (check *Checker) incomparableCause(typ <b>Type</b>) string {
		<a href="../../src/go/types/expr.go.html#line-926" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-926">#L926</a>: func newTarget(typ <b>Type</b>, desc string) *target {
		<a href="../../src/go/types/expr.go.html#line-942" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-942">#L942</a>: func (check *Checker) rawExpr(T *target, x *operand, e ast.Expr, hint <b>Type</b>, allowGeneric bool) exprKind {
		<a href="../../src/go/types/expr.go.html#line-995" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-995">#L995</a>: func (check *Checker) exprInternal(T *target, x *operand, e ast.Expr, hint <b>Type</b>) exprKind {
		<a href="../../src/go/types/expr.go.html#line-1099" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1099">#L1099</a>: 			var base <b>Type</b>
		<a href="../../src/go/types/expr.go.html#line-1100" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1100">#L1100</a>: 			if !underIs(x.typ, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/expr.go.html#line-1207" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1207">#L1207</a>: func (check *Checker) typeAssertion(e ast.Expr, x *operand, T <b>Type</b>, typeSwitch bool) {
		<a href="../../src/go/types/expr.go.html#line-1275" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1275">#L1275</a>: func (check *Checker) exprWithHint(x *operand, e ast.Expr, hint <b>Type</b>) {
		<a href="../../src/go/types/format.go.html#line-41">format.go#L41</a>: 		case <b>Type</b>:
		<a href="../../src/go/types/format.go.html#line-47" class="path-duplicate">format.go</a><a href="../../src/go/types/format.go.html#line-47">#L47</a>: 		case []<b>Type</b>:
		<a href="../../src/go/types/gcsizes.go.html#line-15">gcsizes.go#L15</a>: func (s *gcSizes) Alignof(T <b>Type</b>) (result int64) {
		<a href="../../src/go/types/gcsizes.go.html#line-101" class="path-duplicate">gcsizes.go</a><a href="../../src/go/types/gcsizes.go.html#line-101">#L101</a>: func (s *gcSizes) Sizeof(T <b>Type</b>) int64 {
		<a href="../../src/go/types/index.go.html#line-109">index.go#L109</a>: 		var key, elem <b>Type</b> // key != nil: we must have all maps
		<a href="../../src/go/types/index.go.html#line-112" class="path-duplicate">index.go</a><a href="../../src/go/types/index.go.html#line-112">#L112</a>: 		if underIs(x.typ, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/index.go.html#line-114" class="path-duplicate">index.go</a><a href="../../src/go/types/index.go.html#line-114">#L114</a>: 			var k, e <b>Type</b>  // k is only set for maps
		<a href="../../src/go/types/index.go.html#line-349" class="path-duplicate">index.go</a><a href="../../src/go/types/index.go.html#line-349">#L349</a>: func (check *Checker) index(index ast.Expr, max int64) (typ <b>Type</b>, val int64) {
		<a href="../../src/go/types/infer.go.html#line-35">infer.go#L35</a>: func (check *Checker) infer(posn positioner, tparams []*TypeParam, targs []<b>Type</b>, params *Tuple, args []*operand, reverse bool, err *error_) (inferred []<b>Type</b>) {
		<a href="../../src/go/types/infer.go.html#line-76" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-76">#L76</a>: 		targs2 := make([]<b>Type</b>, n)
		<a href="../../src/go/types/infer.go.html#line-119" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-119">#L119</a>: 	errorf := func(tpar, targ <b>Type</b>, arg *operand) {
		<a href="../../src/go/types/infer.go.html#line-305" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-305">#L305</a>: 				if !check.hasAllMethods(tx, constraint, true, func(x, y <b>Type</b>) bool { return u.unify(x, y, exact) }, &amp;cause) {
		<a href="../../src/go/types/infer.go.html#line-333" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-333">#L333</a>: 	var maxUntyped map[*TypeParam]<b>Type</b> // lazily allocated (we may not need it)
		<a href="../../src/go/types/infer.go.html#line-339" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-339">#L339</a>: 				maxUntyped = make(map[*TypeParam]<b>Type</b>)
		<a href="../../src/go/types/infer.go.html#line-471" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-471">#L471</a>: func (check *Checker) renameTParams(pos token.Pos, tparams []*TypeParam, typ <b>Type</b>) ([]*TypeParam, <b>Type</b>) {
		<a href="../../src/go/types/infer.go.html#line-548" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-548">#L548</a>: func isParameterized(tparams []*TypeParam, typ <b>Type</b>) bool {
		<a href="../../src/go/types/infer.go.html#line-551" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-551">#L551</a>: 		seen:    make(map[<b>Type</b>]bool),
		<a href="../../src/go/types/infer.go.html#line-558" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-558">#L558</a>: 	seen    map[<b>Type</b>]bool
		<a href="../../src/go/types/infer.go.html#line-561" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-561">#L561</a>: func (w *tpWalker) isParameterized(typ <b>Type</b>) (res bool) {
		<a href="../../src/go/types/infer.go.html#line-694" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-694">#L694</a>: func killCycles(tparams []*TypeParam, inferred []<b>Type</b>) {
		<a href="../../src/go/types/infer.go.html#line-695" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-695">#L695</a>: 	w := cycleFinder{tparams, inferred, make(map[<b>Type</b>]bool)}
		<a href="../../src/go/types/infer.go.html#line-703" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-703">#L703</a>: 	inferred []<b>Type</b>
		<a href="../../src/go/types/infer.go.html#line-704" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-704">#L704</a>: 	seen     map[<b>Type</b>]bool
		<a href="../../src/go/types/infer.go.html#line-707" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-707">#L707</a>: func (w *cycleFinder) typ(typ <b>Type</b>) {
		<a href="../../src/go/types/instantiate.go.html#line-23">instantiate.go#L23</a>: 	<b>Type</b>
		<a href="../../src/go/types/instantiate.go.html#line-55" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-55">#L55</a>: func Instantiate(ctxt *Context, orig <b>Type</b>, targs []<b>Type</b>, validate bool) (<b>Type</b>, error) {
		<a href="../../src/go/types/instantiate.go.html#line-91" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-91">#L91</a>: func (check *Checker) instance(pos token.Pos, orig genericType, targs []<b>Type</b>, expanding *Named, ctxt *Context) (res <b>Type</b>) {
		<a href="../../src/go/types/instantiate.go.html#line-116" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-116">#L116</a>: 	updateContexts := func(res <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/instantiate.go.html#line-212" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-212">#L212</a>: func (check *Checker) verify(pos token.Pos, tparams []*TypeParam, targs []<b>Type</b>, ctxt *Context) (int, error) {
		<a href="../../src/go/types/instantiate.go.html#line-236" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-236">#L236</a>: func (check *Checker) implements(V, T <b>Type</b>, constraint bool, cause *string) bool {
		<a href="../../src/go/types/instantiate.go.html#line-344" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-344">#L344</a>: 	var alt <b>Type</b>
		<a href="../../src/go/types/instantiate.go.html#line-381" class="path-duplicate">instantiate.go</a><a href="../../src/go/types/instantiate.go.html#line-381">#L381</a>: func mentions(T, typ <b>Type</b>) bool {
		<a href="../../src/go/types/interface.go.html#line-20">interface.go#L20</a>: 	embeddeds []<b>Type</b>       // ordered list of explicitly embedded elements
		<a href="../../src/go/types/interface.go.html#line-40" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-40">#L40</a>: 	tnames := make([]<b>Type</b>, len(embeddeds))
		<a href="../../src/go/types/interface.go.html#line-53" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-53">#L53</a>: func NewInterfaceType(methods []*Func, embeddeds []<b>Type</b>) *Interface {
		<a href="../../src/go/types/interface.go.html#line-110" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-110">#L110</a>: func (t *Interface) EmbeddedType(i int) <b>Type</b> { return t.embeddeds[i] }
		<a href="../../src/go/types/interface.go.html#line-147" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-147">#L147</a>: func (t *Interface) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/interface.go.html#line-160" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-160">#L160</a>: 	addEmbedded := func(pos token.Pos, typ <b>Type</b>) {
		<a href="../../src/go/types/interface.go.html#line-201" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-201">#L201</a>: 		var recvTyp <b>Type</b> = ityp
		<a href="../../src/go/types/iter.go.html#line-47">iter.go#L47</a>: func (t *Interface) EmbeddedTypes() iter.Seq[<b>Type</b>] {
		<a href="../../src/go/types/iter.go.html#line-48" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-48">#L48</a>: 	return func(yield func(e <b>Type</b>) bool) {
		<a href="../../src/go/types/iter.go.html#line-151" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-151">#L151</a>: func (l *TypeList) Types() iter.Seq[<b>Type</b>] {
		<a href="../../src/go/types/iter.go.html#line-152" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-152">#L152</a>: 	return func(yield func(t <b>Type</b>) bool) {
		<a href="../../src/go/types/literals.go.html#line-111">literals.go#L111</a>: func (check *Checker) compositeLit(x *operand, e *ast.CompositeLit, hint <b>Type</b>) {
		<a href="../../src/go/types/literals.go.html#line-112" class="path-duplicate">literals.go</a><a href="../../src/go/types/literals.go.html#line-112">#L112</a>: 	var typ, base <b>Type</b>
		<a href="../../src/go/types/literals.go.html#line-281" class="path-duplicate">literals.go</a><a href="../../src/go/types/literals.go.html#line-281">#L281</a>: 		visited := make(map[any][]<b>Type</b>, len(e.Elts))
		<a href="../../src/go/types/literals.go.html#line-353" class="path-duplicate">literals.go</a><a href="../../src/go/types/literals.go.html#line-353">#L353</a>: func (check *Checker) indexedElts(elts []ast.Expr, typ <b>Type</b>, length int64) int64 {
		<a href="../../src/go/types/lookup.go.html#line-44">lookup.go#L44</a>: func LookupFieldOrMethod(T <b>Type</b>, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool) {
		<a href="../../src/go/types/lookup.go.html#line-53" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-53">#L53</a>: func lookupFieldOrMethod(T <b>Type</b>, addressable bool, pkg *Package, name string, foldCase bool) (obj Object, index []int, indirect bool) {
		<a href="../../src/go/types/lookup.go.html#line-103" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-103">#L103</a>: func lookupFieldOrMethodImpl(T <b>Type</b>, addressable bool, pkg *Package, name string, foldCase bool) (obj Object, index []int, indirect bool) {
		<a href="../../src/go/types/lookup.go.html#line-236" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-236">#L236</a>: 	typ       <b>Type</b>
		<a href="../../src/go/types/lookup.go.html#line-251" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-251">#L251</a>: 	prev := make(map[<b>Type</b>]int) // index at which type was previously seen
		<a href="../../src/go/types/lookup.go.html#line-265" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-265">#L265</a>: func lookupType(m map[<b>Type</b>]int, typ <b>Type</b>) (int, bool) {
		<a href="../../src/go/types/lookup.go.html#line-324" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-324">#L324</a>: func MissingMethod(V <b>Type</b>, T *Interface, static bool) (method *Func, wrongType bool) {
		<a href="../../src/go/types/lookup.go.html#line-337" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-337">#L337</a>: func (check *Checker) missingMethod(V, T <b>Type</b>, static bool, equivalent func(x, y <b>Type</b>) bool, cause *string) (method *Func, wrongType bool) {
		<a href="../../src/go/types/lookup.go.html#line-488" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-488">#L488</a>: func (check *Checker) hasAllMethods(V, T <b>Type</b>, static bool, equivalent func(x, y <b>Type</b>) bool, cause *string) bool {
		<a href="../../src/go/types/lookup.go.html#line-498" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-498">#L498</a>: func hasInvalidEmbeddedFields(T <b>Type</b>, seen map[*Struct]bool) bool {
		<a href="../../src/go/types/lookup.go.html#line-513" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-513">#L513</a>: func isInterfacePtr(T <b>Type</b>) bool {
		<a href="../../src/go/types/lookup.go.html#line-519" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-519">#L519</a>: func (check *Checker) interfacePtrError(T <b>Type</b>) string {
		<a href="../../src/go/types/lookup.go.html#line-548" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-548">#L548</a>: func (check *Checker) assertableTo(V, T <b>Type</b>, cause *string) bool {
		<a href="../../src/go/types/lookup.go.html#line-564" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-564">#L564</a>: func (check *Checker) newAssertableTo(V, T <b>Type</b>, cause *string) bool {
		<a href="../../src/go/types/lookup.go.html#line-577" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-577">#L577</a>: func deref(typ <b>Type</b>) (<b>Type</b>, bool) {
		<a href="../../src/go/types/lookup.go.html#line-593" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-593">#L593</a>: func derefStructPtr(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/map.go.html#line-12">map.go#L12</a>: 	key, elem <b>Type</b>
		<a href="../../src/go/types/map.go.html#line-16" class="path-duplicate">map.go</a><a href="../../src/go/types/map.go.html#line-16">#L16</a>: func NewMap(key, elem <b>Type</b>) *Map {
		<a href="../../src/go/types/map.go.html#line-21" class="path-duplicate">map.go</a><a href="../../src/go/types/map.go.html#line-21">#L21</a>: func (m *Map) Key() <b>Type</b> { return m.key }
		<a href="../../src/go/types/map.go.html#line-24" class="path-duplicate">map.go</a><a href="../../src/go/types/map.go.html#line-24">#L24</a>: func (m *Map) Elem() <b>Type</b> { return m.elem }
		<a href="../../src/go/types/map.go.html#line-26" class="path-duplicate">map.go</a><a href="../../src/go/types/map.go.html#line-26">#L26</a>: func (t *Map) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/methodset.go.html#line-72">methodset.go#L72</a>: func NewMethodSet(T <b>Type</b>) *MethodSet {
		<a href="../../src/go/types/mono.go.html#line-83">mono.go#L83</a>: 	typ <b>Type</b>
		<a href="../../src/go/types/mono.go.html#line-176" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-176">#L176</a>: func (w *monoGraph) recordInstance(pkg *Package, pos token.Pos, tparams []*TypeParam, targs []<b>Type</b>, xlist []ast.Expr) {
		<a href="../../src/go/types/mono.go.html#line-187" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-187">#L187</a>: func (w *monoGraph) assign(pkg *Package, pos token.Pos, tpar *TypeParam, targ <b>Type</b>) {
		<a href="../../src/go/types/mono.go.html#line-201" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-201">#L201</a>: 	flow := func(src int, typ <b>Type</b>) {
		<a href="../../src/go/types/mono.go.html#line-212" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-212">#L212</a>: 	var do func(typ <b>Type</b>)
		<a href="../../src/go/types/mono.go.html#line-213" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-213">#L213</a>: 	do = func(typ <b>Type</b>) {
		<a href="../../src/go/types/mono.go.html#line-332" class="path-duplicate">mono.go</a><a href="../../src/go/types/mono.go.html#line-332">#L332</a>: func (w *monoGraph) addEdge(dst, src, weight int, pos token.Pos, typ <b>Type</b>) {
		<a href="../../src/go/types/named.go.html#line-116">named.go#L116</a>: 	fromRHS <b>Type</b>
		<a href="../../src/go/types/named.go.html#line-123" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-123">#L123</a>: 	underlying <b>Type</b>           // possibly a *Named during setup; never a *Named once set up completely
		<a href="../../src/go/types/named.go.html#line-134" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-134">#L134</a>: 	loader func(*Named) (tparams []*TypeParam, underlying <b>Type</b>, methods []*Func)
		<a href="../../src/go/types/named.go.html#line-158" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-158">#L158</a>: func NewNamed(obj *TypeName, underlying <b>Type</b>, methods []*Func) *Named {
		<a href="../../src/go/types/named.go.html#line-243" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-243">#L243</a>: func (check *Checker) newNamed(obj *TypeName, underlying <b>Type</b>, methods []*Func) *Named {
		<a href="../../src/go/types/named.go.html#line-261" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-261">#L261</a>: func (check *Checker) newNamedInstance(pos token.Pos, orig *Named, targs []<b>Type</b>, expanding *Named) *Named {
		<a href="../../src/go/types/named.go.html#line-440" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-440">#L440</a>: 	var rtyp <b>Type</b>
		<a href="../../src/go/types/named.go.html#line-453" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-453">#L453</a>: func (t *Named) SetUnderlying(underlying <b>Type</b>) {
		<a href="../../src/go/types/named.go.html#line-507" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-507">#L507</a>: func (t *Named) Underlying() <b>Type</b> {
		<a href="../../src/go/types/named.go.html#line-538" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-538">#L538</a>: func (n0 *Named) under() <b>Type</b> {
		<a href="../../src/go/types/named.go.html#line-632" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-632">#L632</a>: func (n *Named) expandUnderlying() <b>Type</b> {
		<a href="../../src/go/types/named.go.html#line-708" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-708">#L708</a>: func safeUnderlying(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/object.go.html#line-34">object.go#L34</a>: 	Type() <b>Type</b>     // object type
		<a href="../../src/go/types/object.go.html#line-52" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-52">#L52</a>: 	setType(<b>Type</b>)
		<a href="../../src/go/types/object.go.html#line-106" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-106">#L106</a>: 	typ       <b>Type</b>
		<a href="../../src/go/types/object.go.html#line-136" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-136">#L136</a>: func colorFor(t <b>Type</b>) color {
		<a href="../../src/go/types/object.go.html#line-158" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-158">#L158</a>: func (obj *object) Type() <b>Type</b> { return obj.typ }
		<a href="../../src/go/types/object.go.html#line-174" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-174">#L174</a>: func (obj *object) setType(typ <b>Type</b>)          { obj.typ = typ }
		<a href="../../src/go/types/object.go.html#line-268" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-268">#L268</a>: func NewConst(pos token.Pos, pkg *Package, name string, typ <b>Type</b>, val constant.Value) *Const {
		<a href="../../src/go/types/object.go.html#line-293" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-293">#L293</a>: func NewTypeName(pos token.Pos, pkg *Package, name string, typ <b>Type</b>) *TypeName {
		<a href="../../src/go/types/object.go.html#line-299" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-299">#L299</a>: func _NewTypeNameLazy(pos token.Pos, pkg *Package, name string, load func(named *Named) (tparams []*TypeParam, underlying <b>Type</b>, methods []*Func)) *TypeName {
		<a href="../../src/go/types/object.go.html#line-344" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-344">#L344</a>: func NewVar(pos token.Pos, pkg *Package, name string, typ <b>Type</b>) *Var {
		<a href="../../src/go/types/object.go.html#line-349" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-349">#L349</a>: func NewParam(pos token.Pos, pkg *Package, name string, typ <b>Type</b>) *Var {
		<a href="../../src/go/types/object.go.html#line-356" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-356">#L356</a>: func NewField(pos token.Pos, pkg *Package, name string, typ <b>Type</b>, embedded bool) *Var {
		<a href="../../src/go/types/object.go.html#line-398" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-398">#L398</a>: 	var typ <b>Type</b>
		<a href="../../src/go/types/operand.go.html#line-62">operand.go#L62</a>: 	typ  <b>Type</b>
		<a href="../../src/go/types/operand.go.html#line-235" class="path-duplicate">operand.go</a><a href="../../src/go/types/operand.go.html#line-235">#L235</a>: func compositeKind(typ <b>Type</b>) string {
		<a href="../../src/go/types/operand.go.html#line-312" class="path-duplicate">operand.go</a><a href="../../src/go/types/operand.go.html#line-312">#L312</a>: func (x *operand) assignableTo(check *Checker, T <b>Type</b>, cause *string) (bool, Code) {
		<a href="../../src/go/types/pointer.go.html#line-12">pointer.go#L12</a>: 	base <b>Type</b> // element type
		<a href="../../src/go/types/pointer.go.html#line-16" class="path-duplicate">pointer.go</a><a href="../../src/go/types/pointer.go.html#line-16">#L16</a>: func NewPointer(elem <b>Type</b>) *Pointer { return &amp;Pointer{base: elem} }
		<a href="../../src/go/types/pointer.go.html#line-19" class="path-duplicate">pointer.go</a><a href="../../src/go/types/pointer.go.html#line-19">#L19</a>: func (p *Pointer) Elem() <b>Type</b> { return p.base }
		<a href="../../src/go/types/pointer.go.html#line-21" class="path-duplicate">pointer.go</a><a href="../../src/go/types/pointer.go.html#line-21">#L21</a>: func (p *Pointer) Underlying() <b>Type</b> { return p }
		<a href="../../src/go/types/predicates.go.html#line-18">predicates.go#L18</a>: func isValid(t <b>Type</b>) bool { return Unalias(t) != Typ[Invalid] }
		<a href="../../src/go/types/predicates.go.html#line-24" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-24">#L24</a>: func isBoolean(t <b>Type</b>) bool        { return isBasic(t, IsBoolean) }
		<a href="../../src/go/types/predicates.go.html#line-25" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-25">#L25</a>: func isInteger(t <b>Type</b>) bool        { return isBasic(t, IsInteger) }
		<a href="../../src/go/types/predicates.go.html#line-26" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-26">#L26</a>: func isUnsigned(t <b>Type</b>) bool       { return isBasic(t, IsUnsigned) }
		<a href="../../src/go/types/predicates.go.html#line-27" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-27">#L27</a>: func isFloat(t <b>Type</b>) bool          { return isBasic(t, IsFloat) }
		<a href="../../src/go/types/predicates.go.html#line-28" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-28">#L28</a>: func isComplex(t <b>Type</b>) bool        { return isBasic(t, IsComplex) }
		<a href="../../src/go/types/predicates.go.html#line-29" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-29">#L29</a>: func isNumeric(t <b>Type</b>) bool        { return isBasic(t, IsNumeric) }
		<a href="../../src/go/types/predicates.go.html#line-30" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-30">#L30</a>: func isString(t <b>Type</b>) bool         { return isBasic(t, IsString) }
		<a href="../../src/go/types/predicates.go.html#line-31" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-31">#L31</a>: func isIntegerOrFloat(t <b>Type</b>) bool { return isBasic(t, IsInteger|IsFloat) }
		<a href="../../src/go/types/predicates.go.html#line-32" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-32">#L32</a>: func isConstType(t <b>Type</b>) bool      { return isBasic(t, IsConstType) }
		<a href="../../src/go/types/predicates.go.html#line-37" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-37">#L37</a>: func isBasic(t <b>Type</b>, info BasicInfo) bool {
		<a href="../../src/go/types/predicates.go.html#line-48" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-48">#L48</a>: func allBoolean(t <b>Type</b>) bool         { return allBasic(t, IsBoolean) }
		<a href="../../src/go/types/predicates.go.html#line-49" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-49">#L49</a>: func allInteger(t <b>Type</b>) bool         { return allBasic(t, IsInteger) }
		<a href="../../src/go/types/predicates.go.html#line-50" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-50">#L50</a>: func allUnsigned(t <b>Type</b>) bool        { return allBasic(t, IsUnsigned) }
		<a href="../../src/go/types/predicates.go.html#line-51" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-51">#L51</a>: func allNumeric(t <b>Type</b>) bool         { return allBasic(t, IsNumeric) }
		<a href="../../src/go/types/predicates.go.html#line-52" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-52">#L52</a>: func allString(t <b>Type</b>) bool          { return allBasic(t, IsString) }
		<a href="../../src/go/types/predicates.go.html#line-53" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-53">#L53</a>: func allOrdered(t <b>Type</b>) bool         { return allBasic(t, IsOrdered) }
		<a href="../../src/go/types/predicates.go.html#line-54" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-54">#L54</a>: func allNumericOrString(t <b>Type</b>) bool { return allBasic(t, IsNumeric|IsString) }
		<a href="../../src/go/types/predicates.go.html#line-60" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-60">#L60</a>: func allBasic(t <b>Type</b>, info BasicInfo) bool {
		<a href="../../src/go/types/predicates.go.html#line-70" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-70">#L70</a>: func hasName(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-81" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-81">#L81</a>: func isTypeLit(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-92" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-92">#L92</a>: func isTyped(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-101" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-101">#L101</a>: func isUntyped(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-107" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-107">#L107</a>: func isUntypedNumeric(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-115" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-115">#L115</a>: func IsInterface(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-121" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-121">#L121</a>: func isNonTypeParamInterface(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-126" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-126">#L126</a>: func isTypeParam(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-135" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-135">#L135</a>: func hasEmptyTypeset(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-146" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-146">#L146</a>: func isGeneric(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-156" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-156">#L156</a>: func Comparable(T <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-162" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-162">#L162</a>: func comparableType(T <b>Type</b>, dynamic bool, seen map[<b>Type</b>]bool, reportf func(string, ...interface{})) bool {
		<a href="../../src/go/types/predicates.go.html#line-167" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-167">#L167</a>: 		seen = make(map[<b>Type</b>]bool)
		<a href="../../src/go/types/predicates.go.html#line-213" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-213">#L213</a>: func hasNil(t <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-220" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-220">#L220</a>: 		return !isTypeParam(t) || underIs(t, func(u <b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-254" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-254">#L254</a>: func (c *comparer) identical(x, y <b>Type</b>, p *ifacePair) bool {
		<a href="../../src/go/types/predicates.go.html#line-360" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-360">#L360</a>: 			var targs []<b>Type</b>
		<a href="../../src/go/types/predicates.go.html#line-514" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-514">#L514</a>: func identicalInstance(xorig <b>Type</b>, xargs []<b>Type</b>, yorig <b>Type</b>, yargs []<b>Type</b>) bool {
		<a href="../../src/go/types/predicates.go.html#line-525" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-525">#L525</a>: func Default(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/predicates.go.html#line-551" class="path-duplicate">predicates.go</a><a href="../../src/go/types/predicates.go.html#line-551">#L551</a>: func maxType(x, y <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/recording.go.html#line-21">recording.go#L21</a>: 	var typ <b>Type</b>
		<a href="../../src/go/types/recording.go.html#line-59" class="path-duplicate">recording.go</a><a href="../../src/go/types/recording.go.html#line-59">#L59</a>: func (check *Checker) recordTypeAndValue(x ast.Expr, mode operandMode, typ <b>Type</b>, val constant.Value) {
		<a href="../../src/go/types/recording.go.html#line-132" class="path-duplicate">recording.go</a><a href="../../src/go/types/recording.go.html#line-132">#L132</a>: func (check *Checker) recordInstance(expr ast.Expr, targs []<b>Type</b>, typ <b>Type</b>) {
		<a href="../../src/go/types/recording.go.html#line-164" class="path-duplicate">recording.go</a><a href="../../src/go/types/recording.go.html#line-164">#L164</a>: func (check *Checker) recordSelection(x *ast.SelectorExpr, kind SelectionKind, recv <b>Type</b>, obj Object, index []int, indirect bool) {
		<a href="../../src/go/types/scope.go.html#line-205">scope.go#L205</a>: func (*lazyObject) Type() <b>Type</b>                         { panic("unreachable") }
		<a href="../../src/go/types/scope.go.html#line-211" class="path-duplicate">scope.go</a><a href="../../src/go/types/scope.go.html#line-211">#L211</a>: func (*lazyObject) setType(<b>Type</b>)                       { panic("unreachable") }
		<a href="../../src/go/types/selection.go.html#line-77">selection.go#L77</a>: 	recv     <b>Type</b>   // type of x
		<a href="../../src/go/types/selection.go.html#line-87" class="path-duplicate">selection.go</a><a href="../../src/go/types/selection.go.html#line-87">#L87</a>: func (s *Selection) Recv() <b>Type</b> { return s.recv }
		<a href="../../src/go/types/selection.go.html#line-95" class="path-duplicate">selection.go</a><a href="../../src/go/types/selection.go.html#line-95">#L95</a>: func (s *Selection) Type() <b>Type</b> {
		<a href="../../src/go/types/signature.go.html#line-101">signature.go#L101</a>: func (s *Signature) Underlying() <b>Type</b> { return s }
		<a href="../../src/go/types/signature.go.html#line-172" class="path-duplicate">signature.go</a><a href="../../src/go/types/signature.go.html#line-172">#L172</a>: 	var recvType <b>Type</b> = Typ[Invalid]
		<a href="../../src/go/types/signature.go.html#line-261" class="path-duplicate">signature.go</a><a href="../../src/go/types/signature.go.html#line-261">#L261</a>: 			targs := make([]<b>Type</b>, len(recvTParams))
		<a href="../../src/go/types/signature.go.html#line-310" class="path-duplicate">signature.go</a><a href="../../src/go/types/signature.go.html#line-310">#L310</a>: func unpointer(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/signature.go.html#line-330" class="path-duplicate">signature.go</a><a href="../../src/go/types/signature.go.html#line-330">#L330</a>: func (check *Checker) recordParenthesizedRecvTypes(expr ast.Expr, typ <b>Type</b>) {
		<a href="../../src/go/types/sizes.go.html#line-17">sizes.go#L17</a>: 	Alignof(T <b>Type</b>) int64
		<a href="../../src/go/types/sizes.go.html#line-27" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-27">#L27</a>: 	Sizeof(T <b>Type</b>) int64
		<a href="../../src/go/types/sizes.go.html#line-53" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-53">#L53</a>: func (s *StdSizes) Alignof(T <b>Type</b>) (result int64) {
		<a href="../../src/go/types/sizes.go.html#line-117" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-117">#L117</a>: func _IsSyncAtomicAlign64(T <b>Type</b>) bool {
		<a href="../../src/go/types/sizes.go.html#line-167" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-167">#L167</a>: func (s *StdSizes) Sizeof(T <b>Type</b>) int64 {
		<a href="../../src/go/types/sizes.go.html#line-277" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-277">#L277</a>: func (conf *Config) alignof(T <b>Type</b>) int64 {
		<a href="../../src/go/types/sizes.go.html#line-310" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-310">#L310</a>: func (conf *Config) offsetof(T <b>Type</b>, index []int) int64 {
		<a href="../../src/go/types/sizes.go.html#line-329" class="path-duplicate">sizes.go</a><a href="../../src/go/types/sizes.go.html#line-329">#L329</a>: func (conf *Config) sizeof(T <b>Type</b>) int64 {
		<a href="../../src/go/types/slice.go.html#line-12">slice.go#L12</a>: 	elem <b>Type</b>
		<a href="../../src/go/types/slice.go.html#line-16" class="path-duplicate">slice.go</a><a href="../../src/go/types/slice.go.html#line-16">#L16</a>: func NewSlice(elem <b>Type</b>) *Slice { return &amp;Slice{elem: elem} }
		<a href="../../src/go/types/slice.go.html#line-19" class="path-duplicate">slice.go</a><a href="../../src/go/types/slice.go.html#line-19">#L19</a>: func (s *Slice) Elem() <b>Type</b> { return s.elem }
		<a href="../../src/go/types/slice.go.html#line-21" class="path-duplicate">slice.go</a><a href="../../src/go/types/slice.go.html#line-21">#L21</a>: func (s *Slice) Underlying() <b>Type</b> { return s }
		<a href="../../src/go/types/stmt.go.html#line-231">stmt.go#L231</a>: 		typ <b>Type</b>
		<a href="../../src/go/types/stmt.go.html#line-305" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-305">#L305</a>: func (check *Checker) caseTypes(x *operand, types []ast.Expr, seen map[<b>Type</b>]ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/stmt.go.html#line-306" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-306">#L306</a>: 	var T <b>Type</b>
		<a href="../../src/go/types/stmt.go.html#line-357" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-357">#L357</a>: func (check *Checker) caseTypes_currently_unused(x *operand, xtyp *Interface, types []ast.Expr, seen map[string]ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/stmt.go.html#line-358" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-358">#L358</a>: 	var T <b>Type</b>
		<a href="../../src/go/types/stmt.go.html#line-755" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-755">#L755</a>: 		seen := make(map[<b>Type</b>]ast.Expr) // map of seen types to positions
		<a href="../../src/go/types/stmt.go.html#line-893" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-893">#L893</a>: 	var key, val <b>Type</b>
		<a href="../../src/go/types/stmt.go.html#line-924" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-924">#L924</a>: 	rhs := [2]<b>Type</b>{key, val}     // key, val may be nil
		<a href="../../src/go/types/stmt.go.html#line-1032" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-1032">#L1032</a>: func rangeKeyVal(typ <b>Type</b>, allowVersion func(goVersion) bool) (key, val <b>Type</b>, cause string, ok bool) {
		<a href="../../src/go/types/stmt.go.html#line-1033" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-1033">#L1033</a>: 	bad := func(cause string) (<b>Type</b>, <b>Type</b>, string, bool) {
		<a href="../../src/go/types/struct.go.html#line-56">struct.go#L56</a>: func (t *Struct) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/struct.go.html#line-83" class="path-duplicate">struct.go</a><a href="../../src/go/types/struct.go.html#line-83">#L83</a>: 	var typ <b>Type</b>
		<a href="../../src/go/types/subst.go.html#line-16">subst.go#L16</a>: type substMap map[*TypeParam]<b>Type</b>
		<a href="../../src/go/types/subst.go.html#line-20" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-20">#L20</a>: func makeSubstMap(tpars []*TypeParam, targs []<b>Type</b>) substMap {
		<a href="../../src/go/types/subst.go.html#line-44" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-44">#L44</a>: func (m substMap) lookup(tpar *TypeParam) <b>Type</b> {
		<a href="../../src/go/types/subst.go.html#line-58" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-58">#L58</a>: func (check *Checker) subst(pos token.Pos, typ <b>Type</b>, smap substMap, expanding *Named, ctxt *Context) <b>Type</b> {
		<a href="../../src/go/types/subst.go.html#line-92" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-92">#L92</a>: func (subst *subster) typ(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/subst.go.html#line-282" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-282">#L282</a>: func (subst *subster) typOrNil(typ <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/subst.go.html#line-298" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-298">#L298</a>: func cloneVar(v *Var, typ <b>Type</b>) *Var {
		<a href="../../src/go/types/subst.go.html#line-341" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-341">#L341</a>: func cloneFunc(f *Func, typ <b>Type</b>) *Func {
		<a href="../../src/go/types/subst.go.html#line-361" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-361">#L361</a>: func replaceRecvType(in []*Func, old, new <b>Type</b>) (out []*Func, copied bool) {
		<a href="../../src/go/types/termlist.go.html#line-132">termlist.go#L132</a>: func (xl termlist) includes(t <b>Type</b>) bool {
		<a href="../../src/go/types/tuple.go.html#line-36">tuple.go#L36</a>: func (t *Tuple) Underlying() <b>Type</b> { return t }
		<a href="../../src/go/types/type.go.html#line-9">type.go#L9</a>: type <b>Type</b> interface {
		<a href="../../src/go/types/type.go.html#line-14" class="path-duplicate">type.go</a><a href="../../src/go/types/type.go.html#line-14">#L14</a>: 	Underlying() <b>Type</b>
		<a href="../../src/go/types/typelists.go.html#line-31">typelists.go#L31</a>: type TypeList struct{ types []<b>Type</b> }
		<a href="../../src/go/types/typelists.go.html#line-34" class="path-duplicate">typelists.go</a><a href="../../src/go/types/typelists.go.html#line-34">#L34</a>: func newTypeList(list []<b>Type</b>) *TypeList {
		<a href="../../src/go/types/typelists.go.html#line-46" class="path-duplicate">typelists.go</a><a href="../../src/go/types/typelists.go.html#line-46">#L46</a>: func (l *TypeList) At(i int) <b>Type</b> { return l.types[i] }
		<a href="../../src/go/types/typelists.go.html#line-51" class="path-duplicate">typelists.go</a><a href="../../src/go/types/typelists.go.html#line-51">#L51</a>: func (l *TypeList) list() []<b>Type</b> {
		<a href="../../src/go/types/typeparam.go.html#line-30">typeparam.go#L30</a>: 	bound <b>Type</b>      // any type, but underlying is eventually *Interface for correct programs (see TypeParam.iface)
		<a href="../../src/go/types/typeparam.go.html#line-39" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-39">#L39</a>: func NewTypeParam(obj *TypeName, constraint <b>Type</b>) *TypeParam {
		<a href="../../src/go/types/typeparam.go.html#line-44" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-44">#L44</a>: func (check *Checker) newTypeParam(obj *TypeName, constraint <b>Type</b>) *TypeParam {
		<a href="../../src/go/types/typeparam.go.html#line-75" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-75">#L75</a>: func (t *TypeParam) Constraint() <b>Type</b> {
		<a href="../../src/go/types/typeparam.go.html#line-85" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-85">#L85</a>: func (t *TypeParam) SetConstraint(bound <b>Type</b>) {
		<a href="../../src/go/types/typeparam.go.html#line-99" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-99">#L99</a>: func (t *TypeParam) Underlying() <b>Type</b> {
		<a href="../../src/go/types/typeparam.go.html#line-135" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-135">#L135</a>: 		ityp = NewInterfaceType(nil, []<b>Type</b>{bound})
		<a href="../../src/go/types/typeparam.go.html#line-165" class="path-duplicate">typeparam.go</a><a href="../../src/go/types/typeparam.go.html#line-165">#L165</a>: func (t *TypeParam) typeset(yield func(t, u <b>Type</b>) bool) {
		<a href="../../src/go/types/typeset.go.html#line-45">typeset.go#L45</a>: func (s *_TypeSet) IsComparable(seen map[<b>Type</b>]bool) bool {
		<a href="../../src/go/types/typeset.go.html#line-113" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-113">#L113</a>: func (s *_TypeSet) typeset(yield func(t, u <b>Type</b>) bool) {
		<a href="../../src/go/types/typestring.go.html#line-50">typestring.go#L50</a>: func TypeString(typ <b>Type</b>, qf Qualifier) string {
		<a href="../../src/go/types/typestring.go.html#line-59" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-59">#L59</a>: func WriteType(buf *bytes.Buffer, typ <b>Type</b>, qf Qualifier) {
		<a href="../../src/go/types/typestring.go.html#line-72" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-72">#L72</a>: 	seen         map[<b>Type</b>]bool
		<a href="../../src/go/types/typestring.go.html#line-82" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-82">#L82</a>: 	return &amp;typeWriter{buf, make(map[<b>Type</b>]bool), qf, nil, nil, true, false, false}
		<a href="../../src/go/types/typestring.go.html#line-87" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-87">#L87</a>: 	return &amp;typeWriter{buf, make(map[<b>Type</b>]bool), nil, ctxt, nil, false, false, false}
		<a href="../../src/go/types/typestring.go.html#line-115" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-115">#L115</a>: func (w *typeWriter) typ(typ <b>Type</b>) {
		<a href="../../src/go/types/typestring.go.html#line-396" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-396">#L396</a>: func (w *typeWriter) typeList(list []<b>Type</b>) {
		<a href="../../src/go/types/typestring.go.html#line-409" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-409">#L409</a>: 	var prev <b>Type</b>
		<a href="../../src/go/types/typeterm.go.html#line-18">typeterm.go#L18</a>: 	typ   <b>Type</b>
		<a href="../../src/go/types/typeterm.go.html#line-109" class="path-duplicate">typeterm.go</a><a href="../../src/go/types/typeterm.go.html#line-109">#L109</a>: func (x *term) includes(t <b>Type</b>) bool {
		<a href="../../src/go/types/typexpr.go.html#line-150">typexpr.go#L150</a>: func (check *Checker) typ(e ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-157" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-157">#L157</a>: func (check *Checker) varType(e ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-165" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-165">#L165</a>: func (check *Checker) validVarType(e ast.Expr, typ <b>Type</b>) {
		<a href="../../src/go/types/typexpr.go.html#line-192" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-192">#L192</a>: func (check *Checker) definedType(e ast.Expr, def *TypeName) <b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-210" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-210">#L210</a>: func (check *Checker) genericType(e ast.Expr, cause *string) <b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-226" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-226">#L226</a>: func goTypeName(typ <b>Type</b>) string {
		<a href="../../src/go/types/typexpr.go.html#line-232" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-232">#L232</a>: func (check *Checker) typInternal(e0 ast.Expr, def *TypeName) (T <b>Type</b>) {
		<a href="../../src/go/types/typexpr.go.html#line-238" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-238">#L238</a>: 			var under <b>Type</b>
		<a href="../../src/go/types/typexpr.go.html#line-418" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-418">#L418</a>: func setDefType(def *TypeName, typ <b>Type</b>) {
		<a href="../../src/go/types/typexpr.go.html#line-433" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-433">#L433</a>: func (check *Checker) instantiatedType(ix *indexedExpr, def *TypeName) (res <b>Type</b>) {
		<a href="../../src/go/types/typexpr.go.html#line-556" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-556">#L556</a>: func (check *Checker) typeList(list []ast.Expr) []<b>Type</b> {
		<a href="../../src/go/types/typexpr.go.html#line-557" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-557">#L557</a>: 	res := make([]<b>Type</b>, len(list)) // res != nil even if len(list) == 0
		<a href="../../src/go/types/under.go.html#line-14">under.go#L14</a>: func under(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/under.go.html#line-23" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-23">#L23</a>: func underIs(typ <b>Type</b>, f func(<b>Type</b>) bool) bool {
		<a href="../../src/go/types/under.go.html#line-25" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-25">#L25</a>: 	typeset(typ, func(_, u <b>Type</b>) bool {
		<a href="../../src/go/types/under.go.html#line-38" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-38">#L38</a>: func typeset(t <b>Type</b>, yield func(t, u <b>Type</b>) bool) {
		<a href="../../src/go/types/under.go.html#line-52" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-52">#L52</a>: func coreType(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/under.go.html#line-53" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-53">#L53</a>: 	var su <b>Type</b>
		<a href="../../src/go/types/under.go.html#line-54" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-54">#L54</a>: 	typeset(t, func(_, u <b>Type</b>) bool {
		<a href="../../src/go/types/under.go.html#line-75" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-75">#L75</a>: func coreString(t <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/under.go.html#line-82" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-82">#L82</a>: 	var su <b>Type</b>
		<a href="../../src/go/types/under.go.html#line-84" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-84">#L84</a>: 	typeset(t, func(_, u <b>Type</b>) bool {
		<a href="../../src/go/types/under.go.html#line-115" class="path-duplicate">under.go</a><a href="../../src/go/types/under.go.html#line-115">#L115</a>: func match(x, y <b>Type</b>) <b>Type</b> {
		<a href="../../src/go/types/unify.go.html#line-82">unify.go#L82</a>: 	handles                  map[*TypeParam]*<b>Type</b>
		<a href="../../src/go/types/unify.go.html#line-91" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-91">#L91</a>: func newUnifier(tparams []*TypeParam, targs []<b>Type</b>, enableInterfaceInference bool) *unifier {
		<a href="../../src/go/types/unify.go.html#line-93" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-93">#L93</a>: 	handles := make(map[*TypeParam]*<b>Type</b>, len(tparams))
		<a href="../../src/go/types/unify.go.html#line-99" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-99">#L99</a>: 		var t <b>Type</b>
		<a href="../../src/go/types/unify.go.html#line-143" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-143">#L143</a>: func (u *unifier) unify(x, y <b>Type</b>, mode unifyMode) bool {
		<a href="../../src/go/types/unify.go.html#line-213" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-213">#L213</a>: func (u *unifier) asBoundTypeParam(x <b>Type</b>) *TypeParam {
		<a href="../../src/go/types/unify.go.html#line-224" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-224">#L224</a>: func (u *unifier) setHandle(x *TypeParam, h *<b>Type</b>) {
		<a href="../../src/go/types/unify.go.html#line-235" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-235">#L235</a>: func (u *unifier) at(x *TypeParam) <b>Type</b> {
		<a href="../../src/go/types/unify.go.html#line-241" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-241">#L241</a>: func (u *unifier) set(x *TypeParam, t <b>Type</b>) {
		<a href="../../src/go/types/unify.go.html#line-264" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-264">#L264</a>: func (u *unifier) inferred(tparams []*TypeParam) []<b>Type</b> {
		<a href="../../src/go/types/unify.go.html#line-265" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-265">#L265</a>: 	list := make([]<b>Type</b>, len(tparams))
		<a href="../../src/go/types/unify.go.html#line-274" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-274">#L274</a>: func asInterface(x <b>Type</b>) (i *Interface) {
		<a href="../../src/go/types/unify.go.html#line-285" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-285">#L285</a>: func (u *unifier) nify(x, y <b>Type</b>, mode unifyMode, p *ifacePair) (result bool) {
		<a href="../../src/go/types/union.go.html#line-33">union.go#L33</a>: func (u *Union) Underlying() <b>Type</b> { return u }
		<a href="../../src/go/types/union.go.html#line-40" class="path-duplicate">union.go</a><a href="../../src/go/types/union.go.html#line-40">#L40</a>: func NewTerm(tilde bool, typ <b>Type</b>) *Term { return &amp;Term{tilde, typ} }
		<a href="../../src/go/types/union.go.html#line-43" class="path-duplicate">union.go</a><a href="../../src/go/types/union.go.html#line-43">#L43</a>: func (t *Term) Type() <b>Type</b>     { return t.typ }
		<a href="../../src/go/types/union.go.html#line-54" class="path-duplicate">union.go</a><a href="../../src/go/types/union.go.html#line-54">#L54</a>: func parseUnion(check *Checker, uexpr ast.Expr) <b>Type</b> {
		<a href="../../src/go/types/union.go.html#line-60" class="path-duplicate">union.go</a><a href="../../src/go/types/union.go.html#line-60">#L60</a>: 	var u <b>Type</b>
		<a href="../../src/go/types/universe.go.html#line-27">universe.go#L27</a>: 	universeBool       <b>Type</b>
		<a href="../../src/go/types/universe.go.html#line-28" class="path-duplicate">universe.go</a><a href="../../src/go/types/universe.go.html#line-28">#L28</a>: 	universeByte       <b>Type</b> // uint8 alias, but has name "byte"
		<a href="../../src/go/types/universe.go.html#line-29" class="path-duplicate">universe.go</a><a href="../../src/go/types/universe.go.html#line-29">#L29</a>: 	universeRune       <b>Type</b> // int32 alias, but has name "rune"
		<a href="../../src/go/types/universe.go.html#line-32" class="path-duplicate">universe.go</a><a href="../../src/go/types/universe.go.html#line-32">#L32</a>: 	universeError      <b>Type</b>
		<a href="../../src/go/types/validtype.go.html#line-30">validtype.go#L30</a>: func (check *Checker) validType0(pos token.Pos, typ <b>Type</b>, nest, path []*Named) bool {

	<a href="../../pkg/golang.org/x/exp/apidiff.html">golang.org/x/exp/apidiff</a>
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-206">apidiff.go#L206</a>: 	d.correspondMap.Iterate(func(k1 types.<b>Type</b>, v1 any) {
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-209" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-209">#L209</a>: 		nt1 := v1.(types.<b>Type</b>)
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-222" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-222">#L222</a>: 		d.correspondMap.Iterate(func(k2 types.<b>Type</b>, v2 any) {
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-225" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-225">#L225</a>: 			nt2 := v2.(types.<b>Type</b>)
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-305" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-305">#L305</a>: func (d *differ) checkCorrespondence(obj objectWithSide, part string, old, new types.<b>Type</b>) {
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-311" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-311">#L311</a>: func (d *differ) typeChanged(obj objectWithSide, part string, old, new types.<b>Type</b>) {
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-324" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-324">#L324</a>: func removeNamesFromSignature(t types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-9">compatibility.go#L9</a>: func (d *differ) checkCompatible(otn *types.TypeName, old, new types.<b>Type</b>) {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-261" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-261">#L261</a>: func (d *differ) checkCompatibleDefined(otn *types.TypeName, old *types.Named, new types.<b>Type</b>) {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-284" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-284">#L284</a>: func (d *differ) checkMethodSet(otn *types.TypeName, oldt, newt types.<b>Type</b>, addcompat bool) {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-334" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-334">#L334</a>: func exportedMethods(t types.<b>Type</b>) map[string]types.Object {
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-346" class="path-duplicate">compatibility.go</a><a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-346">#L346</a>: func receiverType(method types.Object) types.<b>Type</b> {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-17">correspondence.go#L17</a>: func (d *differ) correspond(old, new types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-29" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-29">#L29</a>: func (d *differ) corr(old, new types.<b>Type</b>, p *ifacePair) bool {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-161" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-161">#L161</a>: func (d *differ) establishCorrespondence(old *types.Named, new types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-166" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-166">#L166</a>: 		return types.Identical(c.(types.<b>Type</b>), new)

	<a href="../../pkg/golang.org/x/tools/go/types/objectpath.html">golang.org/x/tools/go/types/objectpath</a>
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-457">objectpath.go#L457</a>: func find(obj types.Object, T types.<b>Type</b>, path []byte) []byte {
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-468" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-468">#L468</a>: func (f *finder) find(T types.<b>Type</b>, path []byte) []byte {
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-600" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-600">#L600</a>: 		Elem() types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-617" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-617">#L617</a>: 	var t types.<b>Type</b>

	<a href="../../pkg/golang.org/x/tools/go/types/typeutil.html">golang.org/x/tools/go/types/typeutil</a>
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-40">map.go#L40</a>: 	key   types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-52" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-52">#L52</a>: func (m *Map) Delete(key types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-71" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-71">#L71</a>: func (m *Map) At(key types.<b>Type</b>) any {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-84" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-84">#L84</a>: func (m *Map) Set(key types.<b>Type</b>, value any) (prev any) {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-128" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-128">#L128</a>: func (m *Map) Iterate(f func(key types.<b>Type</b>, value any)) {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-142" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-142">#L142</a>: func (m *Map) Keys() []types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-143" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-143">#L143</a>: 	keys := make([]types.<b>Type</b>, 0, m.Len())
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-144" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-144">#L144</a>: 	m.Iterate(func(key types.<b>Type</b>, _ any) {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-157" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-157">#L157</a>: 	m.Iterate(func(key types.<b>Type</b>, value any) {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-186" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-186">#L186</a>: func hash(t types.<b>Type</b>) uint32 {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-202" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-202">#L202</a>: func (h Hasher) Hash(t types.<b>Type</b>) uint32 {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-222" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-222">#L222</a>: func (h hasher) hash(t types.<b>Type</b>) uint32 {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-415" class="path-duplicate">map.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/map.go.html#line-415">#L415</a>: func (h hasher) shallowHash(t types.<b>Type</b>) uint32 {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-20">methodsetcache.go#L20</a>: 	others map[types.<b>Type</b>]*types.MethodSet                            // all other types
		<a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-28" class="path-duplicate">methodsetcache.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-28">#L28</a>: func (cache *MethodSetCache) MethodSet(T types.<b>Type</b>) *types.MethodSet {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-51" class="path-duplicate">methodsetcache.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/methodsetcache.go.html#line-51">#L51</a>: 			cache.others = make(map[types.<b>Type</b>]*types.MethodSet)
		<a href="../../src/golang.org/x/tools/go/types/typeutil/ui.go.html#line-27">ui.go#L27</a>: func IntuitiveMethodSet(T types.<b>Type</b>, msets *MethodSetCache) []*types.Selection {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/ui.go.html#line-28" class="path-duplicate">ui.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/ui.go.html#line-28">#L28</a>: 	isPointerToConcrete := func(T types.<b>Type</b>) bool {

	<a href="../../pkg/golang.org/x/tools/internal/aliases.html">golang.org/x/tools/internal/aliases</a>
		<a href="../../src/golang.org/x/tools/internal/aliases/aliases.go.html#line-28">aliases.go#L28</a>: func NewAlias(enabled bool, pos token.Pos, pkg *types.Package, name string, rhs types.<b>Type</b>, tparams []*types.TypeParam) *types.TypeName {
		<a href="../../src/golang.org/x/tools/internal/aliases/aliases_go122.go.html#line-15">aliases_go122.go#L15</a>: func Rhs(alias *types.Alias) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/aliases/aliases_go122.go.html#line-16" class="path-duplicate">aliases_go122.go</a><a href="../../src/golang.org/x/tools/internal/aliases/aliases_go122.go.html#line-16">#L16</a>: 	if alias, ok := any(alias).(interface{ Rhs() types.<b>Type</b> }); ok {

	<a href="../../pkg/golang.org/x/tools/internal/gcimporter.html">golang.org/x/tools/internal/gcimporter</a>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-365">iexport.go#L365</a>: 		typIndex:    map[types.<b>Type</b>]uint64{},
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-598" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-598">#L598</a>: 	typIndex    map[types.<b>Type</b>]uint64
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-966" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-966">#L966</a>: func (w *exportWriter) typ(t types.<b>Type</b>, pkg *types.Package) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-980" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-980">#L980</a>: func (p *iexporter) typOff(t types.<b>Type</b>, pkg *types.Package) uint64 {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-995" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-995">#L995</a>: func (w *exportWriter) doTyp(t types.<b>Type</b>, pkg *types.Package) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1289" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1289">#L1289</a>: func (w *exportWriter) value(typ types.<b>Type</b>, v constant.Value) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1392" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1392">#L1392</a>: func (w *exportWriter) mpint(x *big.Int, typ types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1460" class="path-duplicate">iexport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-1460">#L1460</a>: func (w *exportWriter) mpfloat(f *big.Float, typ types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-226">iimport.go#L226</a>: 		typCache: make(map[uint64]types.<b>Type</b>),
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-229" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-229">#L229</a>: 		tparamIndex: make(map[ident]types.<b>Type</b>),
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-366" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-366">#L366</a>: 	constraint types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-386" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-386">#L386</a>: 	typCache    map[uint64]types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-387" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-387">#L387</a>: 	tparamIndex map[ident]types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-396" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-396">#L396</a>: 	instanceList []types.<b>Type</b> // instances for later completion (see golang/go#61561)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-514" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-514">#L514</a>: func (p *iimporter) typAt(off uint64, base *types.Named) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-539" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-539">#L539</a>: func canReuse(def *types.Named, rhs types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-688" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-688">#L688</a>: func (r *importReader) value() (typ types.<b>Type</b>, val constant.Value) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-864" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-864">#L864</a>: func (r *importReader) typ() types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-868" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-868">#L868</a>: func isInterface(t types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-876" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-876">#L876</a>: func (r *importReader) doType(base *types.Named) (res types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-946" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-946">#L946</a>: 		embeddeds := make([]types.<b>Type</b>, r.uint64())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-1002" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-1002">#L1002</a>: 		targs := make([]types.<b>Type</b>, len)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/predeclared.go.html#line-17">predeclared.go#L17</a>: var predecl map[types.<b>Type</b>][]types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/predeclared.go.html#line-19" class="path-duplicate">predeclared.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/predeclared.go.html#line-19">#L19</a>: func predeclared() []types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/predeclared.go.html#line-30" class="path-duplicate">predeclared.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/predeclared.go.html#line-30">#L30</a>: 		predecl = make(map[types.<b>Type</b>][]types.<b>Type</b>)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/predeclared.go.html#line-33" class="path-duplicate">predeclared.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/predeclared.go.html#line-33">#L33</a>: 	decls := []types.<b>Type</b>{ // basic types
		<a href="../../src/golang.org/x/tools/internal/gcimporter/predeclared.go.html#line-90" class="path-duplicate">predeclared.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/predeclared.go.html#line-90">#L90</a>: func (t anyType) Underlying() types.<b>Type</b> { return t }
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-35">ureader_yes.go#L35</a>: 	typs     []types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-41" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-41">#L41</a>: 	laterFors map[types.<b>Type</b>]int
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-80" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-80">#L80</a>: func (pr *pkgReader) laterFor(t types.<b>Type</b>, fn func()) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-82" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-82">#L82</a>: 		pr.laterFors = make(map[types.<b>Type</b>]int)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-105" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-105">#L105</a>: 		typs:     make([]types.<b>Type</b>, input.NumElems(pkgbits.RelocType)),
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-173" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-173">#L173</a>: 	derivedTypes []types.<b>Type</b> // lazily instantiated from derived
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-295" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-295">#L295</a>: func (r *reader) typ() types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-307" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-307">#L307</a>: func (pr *pkgReader) typIdx(info typeInfo, dict *readerDict) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-309" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-309">#L309</a>: 	var where *types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-321" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-321">#L321</a>: 	var typ types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-339" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-339">#L339</a>: func (r *reader) doTyp() (res types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-414" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-414">#L414</a>: 	embeddeds := make([]types.<b>Type</b>, r.Len())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-478" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-478">#L478</a>: func (r *reader) obj() (types.Object, []types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-488" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-488">#L488</a>: 	targs := make([]types.<b>Type</b>, r.Len())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-565" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-565">#L565</a>: 			setUnderlying := func(underlying types.<b>Type</b>) {
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-580" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-580">#L580</a>: 					embeds := make([]types.<b>Type</b>, iface.NumEmbeddeds())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-649" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-649">#L649</a>: 		dict.derivedTypes = make([]types.<b>Type</b>, len(dict.derived))
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-690" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-690">#L690</a>: 	typs := make([]types.<b>Type</b>, len(r.dict.bounds))

	<a href="../../pkg/golang.org/x/tools/internal/typeparams.html">golang.org/x/tools/internal/typeparams</a>
		<a href="../../src/golang.org/x/tools/internal/typeparams/common.go.html#line-65">common.go#L65</a>: func IsTypeParam(t types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-15">coretype.go#L15</a>: func CoreType(T types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-112" class="path-duplicate">coretype.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-112">#L112</a>: func NormalTerms(T types.<b>Type</b>) ([]*types.Term, error) {
		<a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-138" class="path-duplicate">coretype.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-138">#L138</a>: func Deref(t types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-150" class="path-duplicate">coretype.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/coretype.go.html#line-150">#L150</a>: func MustDeref(t types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/typeparams/free.go.html#line-19">free.go#L19</a>: 	seen map[types.<b>Type</b>]bool
		<a href="../../src/golang.org/x/tools/internal/typeparams/free.go.html#line-23" class="path-duplicate">free.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/free.go.html#line-23">#L23</a>: func (w *Free) Has(typ types.<b>Type</b>) (res bool) {
		<a href="../../src/golang.org/x/tools/internal/typeparams/free.go.html#line-29" class="path-duplicate">free.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/free.go.html#line-29">#L29</a>: 		w.seen = make(map[types.<b>Type</b>]bool)
		<a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-95">normalize.go#L95</a>: func computeTermSet(typ types.<b>Type</b>) ([]*types.Term, error) {
		<a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-96" class="path-duplicate">normalize.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-96">#L96</a>: 	tset, err := computeTermSetInternal(typ, make(map[types.<b>Type</b>]*termSet), 0)
		<a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-127" class="path-duplicate">normalize.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-127">#L127</a>: func computeTermSetInternal(t types.<b>Type</b>, seen map[types.<b>Type</b>]*termSet, depth int) (res *termSet, err error) {
		<a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-216" class="path-duplicate">normalize.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/normalize.go.html#line-216">#L216</a>: func under(t types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/typeparams/termlist.go.html#line-137">termlist.go#L137</a>: func (xl termlist) includes(t types.<b>Type</b>) bool {
		<a href="../../src/golang.org/x/tools/internal/typeparams/typeterm.go.html#line-22">typeterm.go#L22</a>: 	typ   types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/typeparams/typeterm.go.html#line-113" class="path-duplicate">typeterm.go</a><a href="../../src/golang.org/x/tools/internal/typeparams/typeterm.go.html#line-113">#L113</a>: func (x *term) includes(t types.<b>Type</b>) bool {

	<a href="../../pkg/golang.org/x/tools/internal/typesinternal.html">golang.org/x/tools/internal/typesinternal</a>
		<a href="../../src/golang.org/x/tools/internal/typesinternal/element.go.html#line-25">element.go#L25</a>: func ForEachElement(rtypes *typeutil.Map, msets *typeutil.MethodSetCache, T types.<b>Type</b>, f func(types.<b>Type</b>)) {
		<a href="../../src/golang.org/x/tools/internal/typesinternal/element.go.html#line-26" class="path-duplicate">element.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/element.go.html#line-26">#L26</a>: 	var visit func(T types.<b>Type</b>, skip bool)
		<a href="../../src/golang.org/x/tools/internal/typesinternal/element.go.html#line-27" class="path-duplicate">element.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/element.go.html#line-27">#L27</a>: 	visit = func(T types.<b>Type</b>, skip bool) {
		<a href="../../src/golang.org/x/tools/internal/typesinternal/recv.go.html#line-39">recv.go#L39</a>: func Unpointer(t types.<b>Type</b>) types.<b>Type</b> {
		<a href="../../src/golang.org/x/tools/internal/typesinternal/types.go.html#line-83">types.go#L83</a>: func TypeNameFor(t types.<b>Type</b>) *types.TypeName {
		<a href="../../src/golang.org/x/tools/internal/typesinternal/types.go.html#line-114" class="path-duplicate">types.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/types.go.html#line-114">#L114</a>: 	types.<b>Type</b>
		<a href="../../src/golang.org/x/tools/internal/typesinternal/zerovalue.go.html#line-34">zerovalue.go#L34</a>: func ZeroString(t types.<b>Type</b>, qual types.Qualifier) (_ string, isValid bool) {
		<a href="../../src/golang.org/x/tools/internal/typesinternal/zerovalue.go.html#line-127" class="path-duplicate">zerovalue.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/zerovalue.go.html#line-127">#L127</a>: func ZeroExpr(t types.<b>Type</b>, qual types.Qualifier) (_ ast.Expr, isValid bool) {
		<a href="../../src/golang.org/x/tools/internal/typesinternal/zerovalue.go.html#line-224" class="path-duplicate">zerovalue.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/zerovalue.go.html#line-224">#L224</a>: func TypeExpr(t types.<b>Type</b>, qual types.Qualifier) ast.Expr {
</code></pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.7.6</i>. (GOOS=linux GOARCH=amd64)</pre>