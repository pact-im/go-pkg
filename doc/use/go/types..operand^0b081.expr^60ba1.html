<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>References: go/types.operand.expr</title>
<link href="../../css/auto-v0.7.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.7.6.js"></script>
<body onload="onPageLoad()"><div>

<pre><code><span style="font-size:x-large;"><b><a href="../../pkg/go/types.html">go/types</a>.<a href="../../src/go/types/operand.go.html#line-59">operand</a>.<a href="../../src/go/types/operand.go.html#line-61">expr</a></b></span><span style="font-size: large;"><i> (field)</i></span>

<span class="title">79 uses</span>

	go/types (current package)
		<a href="../../src/go/types/assignments.go.html#line-87">assignments.go#L87</a>: 			check.updateExprVal(x.<b>expr</b>, val)
		<a href="../../src/go/types/assignments.go.html#line-91" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-91">#L91</a>: 			check.updateExprType(x.<b>expr</b>, newType, false)
		<a href="../../src/go/types/assignments.go.html#line-234" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-234">#L234</a>: 		if sel, ok := x.<b>expr</b>.(*ast.SelectorExpr); ok {
		<a href="../../src/go/types/assignments.go.html#line-238" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-238">#L238</a>: 				check.errorf(&amp;x, UnaddressableFieldAssign, "cannot assign to struct field %s in map", ExprString(x.<b>expr</b>))
		<a href="../../src/go/types/assignments.go.html#line-242" class="path-duplicate">assignments.go</a><a href="../../src/go/types/assignments.go.html#line-242">#L242</a>: 		check.errorf(&amp;x, UnassignableOperand, "cannot assign to %s (neither addressable nor a map index expression)", x.<b>expr</b>)
		<a href="../../src/go/types/builtins.go.html#line-604">builtins.go#L604</a>: 					check.errorf(a, MismatchedTypes, invalidArg+"mismatched types %s (previous argument) and %s (type of %s)", x.typ, a.typ, a.<b>expr</b>)
		<a href="../../src/go/types/builtins.go.html#line-630" class="path-duplicate">builtins.go</a><a href="../../src/go/types/builtins.go.html#line-630">#L630</a>: 			check.updateExprType(a.<b>expr</b>, x.typ, true)
		<a href="../../src/go/types/call.go.html#line-40">call.go#L40</a>: 		x.<b>expr</b> = ix.orig // if we don't have an index expression, keep the existing expression of x
		<a href="../../src/go/types/call.go.html#line-104" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-104">#L104</a>: 			args = []*operand{{mode: value, <b>expr</b>: expr, typ: T.sig}}
		<a href="../../src/go/types/call.go.html#line-126" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-126">#L126</a>: 	sig = check.instantiateSignature(x.Pos(), x.<b>expr</b>, sig, targs, xlist)
		<a href="../../src/go/types/call.go.html#line-183" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-183">#L183</a>: 		x.<b>expr</b> = call.Fun
		<a href="../../src/go/types/call.go.html#line-193" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-193">#L193</a>: 		x.<b>expr</b> = call
		<a href="../../src/go/types/call.go.html#line-226" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-226">#L226</a>: 		x.<b>expr</b> = call
		<a href="../../src/go/types/call.go.html#line-235" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-235">#L235</a>: 		x.<b>expr</b> = call
		<a href="../../src/go/types/call.go.html#line-258" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-258">#L258</a>: 		x.<b>expr</b> = call
		<a href="../../src/go/types/call.go.html#line-275" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-275">#L275</a>: 			x.<b>expr</b> = call
		<a href="../../src/go/types/call.go.html#line-286" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-286">#L286</a>: 			x.<b>expr</b> = call
		<a href="../../src/go/types/call.go.html#line-329" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-329">#L329</a>: 	x.<b>expr</b> = call
		<a href="../../src/go/types/call.go.html#line-399" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-399">#L399</a>: 				x.<b>expr</b> = ix.orig
		<a href="../../src/go/types/call.go.html#line-414" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-414">#L414</a>: 					resList[i] = &amp;operand{mode: value, <b>expr</b>: e, typ: v.typ}
		<a href="../../src/go/types/call.go.html#line-434" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-434">#L434</a>: 					x.<b>expr</b> = ix.orig
		<a href="../../src/go/types/call.go.html#line-524" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-524">#L524</a>: 			at = args[npars].<b>expr</b> // report at first extra argument
		<a href="../../src/go/types/call.go.html#line-646" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-646">#L646</a>: 			arg.typ = check.instantiateSignature(call.Pos(), arg.<b>expr</b>, asig, targs[j:k], nil) // TODO(gri) provide xlist if possible (partial instantiations)
		<a href="../../src/go/types/call.go.html#line-775" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-775">#L775</a>: 			x.<b>expr</b> = e
		<a href="../../src/go/types/call.go.html#line-824" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-824">#L824</a>: 			check.errorf(e.Sel, AmbiguousSelector, "ambiguous selector %s.%s", x.<b>expr</b>, sel)
		<a href="../../src/go/types/call.go.html#line-844" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-844">#L844</a>: 		check.errorf(e.Sel, MissingFieldOrMethod, "%s.%s undefined (%s)", x.<b>expr</b>, sel, why)
		<a href="../../src/go/types/call.go.html#line-857" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-857">#L857</a>: 			check.errorf(e.Sel, MissingFieldOrMethod, "%s.%s undefined (type %s has no method %s)", x.<b>expr</b>, sel, x.typ, sel)
		<a href="../../src/go/types/call.go.html#line-977" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-977">#L977</a>: 	x.<b>expr</b> = e
		<a href="../../src/go/types/call.go.html#line-982" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-982">#L982</a>: 	x.<b>expr</b> = e
		<a href="../../src/go/types/const.go.html#line-45">const.go#L45</a>: 		op := opName(x.<b>expr</b>)
		<a href="../../src/go/types/const.go.html#line-302" class="path-duplicate">const.go</a><a href="../../src/go/types/const.go.html#line-302">#L302</a>: 		check.updateExprVal(x.<b>expr</b>, val)
		<a href="../../src/go/types/const.go.html#line-306" class="path-duplicate">const.go</a><a href="../../src/go/types/const.go.html#line-306">#L306</a>: 		check.updateExprType(x.<b>expr</b>, newType, false)
		<a href="../../src/go/types/conversions.go.html#line-119">conversions.go#L119</a>: 		check.updateExprType(x.<b>expr</b>, final, true)
		<a href="../../src/go/types/errors.go.html#line-304">errors.go#L304</a>: 		if x.<b>expr</b> != nil {
		<a href="../../src/go/types/errors.go.html#line-306" class="path-duplicate">errors.go</a><a href="../../src/go/types/errors.go.html#line-306">#L306</a>: 			return posSpan{pos, pos, x.<b>expr</b>.End()}
		<a href="../../src/go/types/expr.go.html#line-185">expr.go#L185</a>: 		x.<b>expr</b> = e
		<a href="../../src/go/types/expr.go.html#line-186" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-186">#L186</a>: 		check.overflow(x, opPos(x.<b>expr</b>))
		<a href="../../src/go/types/expr.go.html#line-570" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-570">#L570</a>: 		check.updateExprType(x.<b>expr</b>, Default(x.typ), true)
		<a href="../../src/go/types/expr.go.html#line-571" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-571">#L571</a>: 		check.updateExprType(y.<b>expr</b>, Default(y.typ), true)
		<a href="../../src/go/types/expr.go.html#line-598" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-598">#L598</a>: 		check.errorf(x, code, "invalid case %s in switch on %s (%s)", x.<b>expr</b>, y.<b>expr</b>, cause) // error position always at 1st operand
		<a href="../../src/go/types/expr.go.html#line-600" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-600">#L600</a>: 		check.errorf(errOp, code, invalidOp+"%s %s %s (%s)", x.<b>expr</b>, op, y.<b>expr</b>, cause)
		<a href="../../src/go/types/expr.go.html#line-710" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-710">#L710</a>: 			x.<b>expr</b> = e
		<a href="../../src/go/types/expr.go.html#line-711" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-711">#L711</a>: 			check.overflow(x, opPos(x.<b>expr</b>))
		<a href="../../src/go/types/expr.go.html#line-736" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-736">#L736</a>: 			if info, found := check.untyped[x.<b>expr</b>]; found {
		<a href="../../src/go/types/expr.go.html#line-738" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-738">#L738</a>: 				check.untyped[x.<b>expr</b>] = info
		<a href="../../src/go/types/expr.go.html#line-790" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-790">#L790</a>: 		x.<b>expr</b> = y.<b>expr</b>
		<a href="../../src/go/types/expr.go.html#line-864" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-864">#L864</a>: 		x.<b>expr</b> = e
		<a href="../../src/go/types/expr.go.html#line-1012" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1012">#L1012</a>: 		check.errorf(x.<b>expr</b>, WrongTypeArgCount, "cannot use generic %s %s without instantiation", what, x.<b>expr</b>)
		<a href="../../src/go/types/expr.go.html#line-1060" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1060">#L1060</a>: 		x.<b>expr</b> = e
		<a href="../../src/go/types/expr.go.html#line-1150" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1150">#L1150</a>: 			x.<b>expr</b> = e
		<a href="../../src/go/types/expr.go.html#line-1180" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1180">#L1180</a>: 	x.<b>expr</b> = e
		<a href="../../src/go/types/expr.go.html#line-1185" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1185">#L1185</a>: 	x.<b>expr</b> = e
		<a href="../../src/go/types/expr.go.html#line-1278" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1278">#L1278</a>: 			list[i] = &amp;operand{mode: value, <b>expr</b>: e, typ: v.typ}
		<a href="../../src/go/types/expr.go.html#line-1286" class="path-duplicate">expr.go</a><a href="../../src/go/types/expr.go.html#line-1286">#L1286</a>: 		x2 := &amp;operand{mode: value, <b>expr</b>: e, typ: Typ[UntypedBool]}
		<a href="../../src/go/types/index.go.html#line-101">index.go#L101</a>: 		x.<b>expr</b> = e.orig
		<a href="../../src/go/types/index.go.html#line-175" class="path-duplicate">index.go</a><a href="../../src/go/types/index.go.html#line-175">#L175</a>: 				x.<b>expr</b> = e.orig
		<a href="../../src/go/types/infer.go.html#line-134">infer.go#L134</a>: 				err.addf(arg, "type %s of %s does not match %s (cannot infer %s)", targ, arg.<b>expr</b>, tpar, typeParamsString(tparams))
		<a href="../../src/go/types/infer.go.html#line-147" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-147">#L147</a>: 				err.addf(arg, "inferred type %s for %s does not match type %s of %s", inferred, tpar, targ, arg.<b>expr</b>)
		<a href="../../src/go/types/infer.go.html#line-149" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-149">#L149</a>: 				err.addf(arg, "type %s of %s does not match inferred type %s for %s", targ, arg.<b>expr</b>, inferred, tpar)
		<a href="../../src/go/types/infer.go.html#line-152" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-152">#L152</a>: 			err.addf(arg, "type %s of %s does not match %s", targ, arg.<b>expr</b>, tpar)
		<a href="../../src/go/types/literals.go.html#line-79">literals.go#L79</a>: 	x.<b>expr</b> = e // make sure that check.overflow below has an error position
		<a href="../../src/go/types/literals.go.html#line-80" class="path-duplicate">literals.go</a><a href="../../src/go/types/literals.go.html#line-80">#L80</a>: 	check.overflow(x, opPos(x.<b>expr</b>))
		<a href="../../src/go/types/operand.go.html#line-61">operand.go#L61</a>: 	<b>expr</b> ast.Expr
		<a href="../../src/go/types/operand.go.html#line-71" class="path-duplicate">operand.go</a><a href="../../src/go/types/operand.go.html#line-71">#L71</a>: 	if x.<b>expr</b> == nil {
		<a href="../../src/go/types/operand.go.html#line-74" class="path-duplicate">operand.go</a><a href="../../src/go/types/operand.go.html#line-74">#L74</a>: 	return x.<b>expr</b>.Pos()
		<a href="../../src/go/types/operand.go.html#line-135" class="path-duplicate">operand.go</a><a href="../../src/go/types/operand.go.html#line-135">#L135</a>: 	if x.<b>expr</b> != nil {
		<a href="../../src/go/types/operand.go.html#line-136" class="path-duplicate">operand.go</a><a href="../../src/go/types/operand.go.html#line-136">#L136</a>: 		expr = ExprString(x.<b>expr</b>)
		<a href="../../src/go/types/range.go.html#line-58">range.go#L58</a>: 				<b>expr</b>: rangeVar,
		<a href="../../src/go/types/range.go.html#line-141" class="path-duplicate">range.go</a><a href="../../src/go/types/range.go.html#line-141">#L141</a>: 				y.<b>expr</b> = lhs // we don't have a better rhs expression to use here
		<a href="../../src/go/types/range.go.html#line-182" class="path-duplicate">range.go</a><a href="../../src/go/types/range.go.html#line-182">#L182</a>: 				y.<b>expr</b> = lhs // we don't have a better rhs expression to use here
		<a href="../../src/go/types/recording.go.html#line-34">recording.go#L34</a>: 	assert(x.<b>expr</b> != nil &amp;&amp; typ != nil)
		<a href="../../src/go/types/recording.go.html#line-39" class="path-duplicate">recording.go</a><a href="../../src/go/types/recording.go.html#line-39">#L39</a>: 		check.rememberUntyped(x.<b>expr</b>, false, x.mode, typ.(*Basic), val)
		<a href="../../src/go/types/recording.go.html#line-41" class="path-duplicate">recording.go</a><a href="../../src/go/types/recording.go.html#line-41">#L41</a>: 		check.recordTypeAndValue(x.<b>expr</b>, x.mode, typ, val)
		<a href="../../src/go/types/stmt.go.html#line-649">stmt.go#L649</a>: 			x.<b>expr</b> = &amp;ast.Ident{NamePos: s.Body.Lbrace, Name: "true"}
		<a href="../../src/go/types/typexpr.go.html#line-23">typexpr.go#L23</a>: 	x.<b>expr</b> = e
</code></pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.7.6</i>. (GOOS=linux GOARCH=amd64)</pre>