<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>References: go/types.object.name</title>
<link href="../../css/auto-v0.7.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.7.6.js"></script>
<body onload="onPageLoad()"><div>

<pre><code><span style="font-size:x-large;"><b><a href="../../pkg/go/types.html">go/types</a>.<a href="../../src/go/types/object.go.html#line-101">object</a>.<a href="../../src/go/types/object.go.html#line-105">name</a></b></span><span style="font-size: large;"><i> (field)</i></span>

<span class="title">90 uses</span>

	go/types (current package)
		<a href="../../src/go/types/alias.go.html#line-120">alias.go#L120</a>: 		panic(fmt.Sprintf("non-terminated alias %s", a0.obj.<b>name</b>))
		<a href="../../src/go/types/alias.go.html#line-167" class="path-duplicate">alias.go</a><a href="../../src/go/types/alias.go.html#line-167">#L167</a>: 	obj := NewTypeName(pos, orig.obj.pkg, orig.obj.<b>name</b>, nil)
		<a href="../../src/go/types/assignments.go.html#line-408">assignments.go#L408</a>: 			desc := lhs.<b>name</b>
		<a href="../../src/go/types/builtins.go.html#line-1076">builtins.go#L1076</a>: 		tpar := NewTypeName(nopos, check.pkg, tp.obj.<b>name</b>, nil)
		<a href="../../src/go/types/call.go.html#line-500">call.go#L500</a>: 					vars = append(vars, NewParam(last.pos, last.pkg, last.<b>name</b>, typ))
		<a href="../../src/go/types/call.go.html#line-757" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-757">#L757</a>: 				if pkg.cgo &amp;&amp; strings.HasPrefix(exp.<b>name</b>, "_Cvar_") {
		<a href="../../src/go/types/call.go.html#line-763" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-763">#L763</a>: 				if pkg.cgo &amp;&amp; strings.HasPrefix(exp.<b>name</b>, "_Cmacro_") {
		<a href="../../src/go/types/call.go.html#line-882" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-882">#L882</a>: 		if len(params) &gt; 0 &amp;&amp; params[0].<b>name</b> != "" {
		<a href="../../src/go/types/call.go.html#line-884" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-884">#L884</a>: 			name = sig.recv.<b>name</b>
		<a href="../../src/go/types/call.go.html#line-951" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-951">#L951</a>: 					check.dump("%v: (%s).%v -&gt; %s", e.Pos(), typ, obj.<b>name</b>, m)
		<a href="../../src/go/types/decl.go.html#line-517">decl.go#L517</a>: 		check.expr(newTarget(obj.typ, obj.<b>name</b>), &amp;x, init)
		<a href="../../src/go/types/decl.go.html#line-790" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-790">#L790</a>: 			assert(m.<b>name</b> != "_")
		<a href="../../src/go/types/decl.go.html#line-799" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-799">#L799</a>: 		assert(m.<b>name</b> != "_")
		<a href="../../src/go/types/decl.go.html#line-802" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-802">#L802</a>: 				check.errorf(m, DuplicateMethod, "method %s.%s already declared at %v", obj.Name(), m.<b>name</b>, alt.Pos())
		<a href="../../src/go/types/decl.go.html#line-804" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-804">#L804</a>: 				check.errorf(m, DuplicateMethod, "method %s.%s already declared", obj.Name(), m.<b>name</b>)
		<a href="../../src/go/types/decl.go.html#line-820" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-820">#L820</a>: 			assert(m.<b>name</b> != "_")
		<a href="../../src/go/types/decl.go.html#line-827" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-827">#L827</a>: 			if fld.<b>name</b> != "_" {
		<a href="../../src/go/types/decl.go.html#line-836" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-836">#L836</a>: 					err.addf(alt, "field and method with the same name %s", fld.<b>name</b>)
		<a href="../../src/go/types/decl.go.html#line-879" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-879">#L879</a>: 			check.funcBody(decl, obj.<b>name</b>, sig, fdecl.Body, nil)
		<a href="../../src/go/types/decl.go.html#line-880" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-880">#L880</a>: 		}).describef(obj, "func %s", obj.<b>name</b>)
		<a href="../../src/go/types/infer.go.html#line-456">infer.go#L456</a>: 			err.addf(posn, "cannot infer %s (declared at %v)", obj.<b>name</b>, obj.pos)
		<a href="../../src/go/types/infer.go.html#line-527" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-527">#L527</a>: 		return list[0].obj.<b>name</b>
		<a href="../../src/go/types/infer.go.html#line-529" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-529">#L529</a>: 		return list[0].obj.<b>name</b> + " and " + list[1].obj.<b>name</b>
		<a href="../../src/go/types/infer.go.html#line-538" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-538">#L538</a>: 		buf.WriteString(tname.obj.<b>name</b>)
		<a href="../../src/go/types/infer.go.html#line-541" class="path-duplicate">infer.go</a><a href="../../src/go/types/infer.go.html#line-541">#L541</a>: 	buf.WriteString(list[n-1].obj.<b>name</b>)
		<a href="../../src/go/types/labels.go.html#line-44">labels.go#L44</a>: 			check.softErrorf(lbl, UnusedLabel, "label %s declared and not used", lbl.<b>name</b>)
		<a href="../../src/go/types/literals.go.html#line-219">literals.go#L219</a>: 					check.errorf(x, UnexportedLitField, "implicit assignment to unexported field %s in struct literal of type %s", fld.<b>name</b>, base)
		<a href="../../src/go/types/lookup.go.html#line-402">lookup.go#L402</a>: 			_, f = tset.LookupMethod(m.pkg, m.<b>name</b>, false)
		<a href="../../src/go/types/lookup.go.html#line-419" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-419">#L419</a>: 			obj, index, indirect := lookupFieldOrMethodImpl(V, false, m.pkg, m.<b>name</b>, false)
		<a href="../../src/go/types/lookup.go.html#line-430" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-430">#L430</a>: 					obj, _, _ = lookupFieldOrMethodImpl(V, false, m.pkg, m.<b>name</b>, true /* fold case */)
		<a href="../../src/go/types/lookup.go.html#line-434" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-434">#L434</a>: 						if f.<b>name</b> == m.<b>name</b> {
		<a href="../../src/go/types/lookup.go.html#line-571" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-571">#L571</a>: 	buf := bytes.NewBufferString(f.<b>name</b>)
		<a href="../../src/go/types/named.go.html#line-264">named.go#L264</a>: 	obj := NewTypeName(pos, orig.obj.pkg, orig.obj.<b>name</b>, nil)
		<a href="../../src/go/types/named.go.html#line-474" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-474">#L474</a>: 	if t.methodIndex(m.<b>name</b>, false) &lt; 0 {
		<a href="../../src/go/types/named.go.html#line-488" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-488">#L488</a>: 			if strings.EqualFold(m.<b>name</b>, name) {
		<a href="../../src/go/types/named.go.html#line-494" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-494">#L494</a>: 			if m.<b>name</b> == name {
		<a href="../../src/go/types/object.go.html#line-105">object.go#L105</a>: 	<b>name</b>      string
		<a href="../../src/go/types/object.go.html#line-155" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-155">#L155</a>: func (obj *object) Name() string { return obj.<b>name</b> }
		<a href="../../src/go/types/object.go.html#line-163" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-163">#L163</a>: func (obj *object) Exported() bool { return isExported(obj.<b>name</b>) }
		<a href="../../src/go/types/object.go.html#line-166" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-166">#L166</a>: func (obj *object) Id() string { return Id(obj.pkg, obj.<b>name</b>) }
		<a href="../../src/go/types/object.go.html#line-181" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-181">#L181</a>: 	if foldCase &amp;&amp; strings.EqualFold(obj.<b>name</b>, name) {
		<a href="../../src/go/types/object.go.html#line-188" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-188">#L188</a>: 	if obj.<b>name</b> != name {
		<a href="../../src/go/types/object.go.html#line-223" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-223">#L223</a>: 	ea := isExported(a.<b>name</b>)
		<a href="../../src/go/types/object.go.html#line-224" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-224">#L224</a>: 	eb := isExported(b.<b>name</b>)
		<a href="../../src/go/types/object.go.html#line-233" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-233">#L233</a>: 	if a.<b>name</b> != b.<b>name</b> {
		<a href="../../src/go/types/object.go.html#line-234" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-234">#L234</a>: 		return strings.Compare(a.<b>name</b>, b.<b>name</b>)
		<a href="../../src/go/types/object.go.html#line-323" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-323">#L323</a>: 		return obj.pkg != nil || t.name != obj.<b>name</b> || t == universeByte || t == universeRune
		<a href="../../src/go/types/object.go.html#line-539" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-539">#L539</a>: 	return &amp;Label{object{pos: pos, pkg: pkg, <b>name</b>: name, typ: Typ[Invalid], color_: black}, false}
		<a href="../../src/go/types/object.go.html#line-550" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-550">#L550</a>: 	return &amp;Builtin{object{<b>name</b>: predeclaredFuncs[id].name, typ: Typ[Invalid], color_: black}, id}
		<a href="../../src/go/types/object.go.html#line-565" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-565">#L565</a>: 		if path := obj.imported.path; path != "" &amp;&amp; path != obj.<b>name</b> {
		<a href="../../src/go/types/object.go.html#line-714" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-714">#L714</a>: 	buf.WriteString(f.<b>name</b>)
		<a href="../../src/go/types/predicates.go.html#line-299">predicates.go#L299</a>: 						!f.sameId(g.pkg, g.<b>name</b>, false) ||
		<a href="../../src/go/types/resolver.go.html#line-711">resolver.go#L711</a>: 		if obj.<b>name</b> != "_" &amp;&amp; !check.usedPkgNames[obj] {
		<a href="../../src/go/types/resolver.go.html#line-729" class="path-duplicate">resolver.go</a><a href="../../src/go/types/resolver.go.html#line-729">#L729</a>: 	if obj.<b>name</b> == "" || obj.<b>name</b> == "." || obj.<b>name</b> == elem {
		<a href="../../src/go/types/resolver.go.html#line-732" class="path-duplicate">resolver.go</a><a href="../../src/go/types/resolver.go.html#line-732">#L732</a>: 		check.softErrorf(obj, UnusedImport, "%q imported as %s and not used", path, obj.<b>name</b>)
		<a href="../../src/go/types/signature.go.html#line-168">signature.go#L168</a>: 	if recv != nil &amp;&amp; recv.<b>name</b> != "" {
		<a href="../../src/go/types/signature.go.html#line-490" class="path-duplicate">signature.go</a><a href="../../src/go/types/signature.go.html#line-490">#L490</a>: 	return strings.HasPrefix(obj.<b>name</b>, "_Ctype_") ||
		<a href="../../src/go/types/stmt.go.html#line-72">stmt.go#L72</a>: 		check.softErrorf(v, UnusedVar, "declared and not used: %s", v.<b>name</b>)
		<a href="../../src/go/types/stmt.go.html#line-547" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-547">#L547</a>: 		if len(s.Results) == 0 &amp;&amp; res.Len() &gt; 0 &amp;&amp; res.vars[0].<b>name</b> != "" {
		<a href="../../src/go/types/stmt.go.html#line-552" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-552">#L552</a>: 				if alt := check.lookup(obj.<b>name</b>); alt != nil &amp;&amp; alt != obj {
		<a href="../../src/go/types/stmt.go.html#line-554" class="path-duplicate">stmt.go</a><a href="../../src/go/types/stmt.go.html#line-554">#L554</a>: 					err.addf(s, "result parameter %s not in scope at return", obj.<b>name</b>)
		<a href="../../src/go/types/struct.go.html#line-30">struct.go#L30</a>: 		if f.<b>name</b> != "_" &amp;&amp; fset.insert(f) != nil {
		<a href="../../src/go/types/typeset.go.html#line-231">typeset.go#L231</a>: 				err.addf(atPos(pos), "duplicate method %s", m.<b>name</b>)
		<a href="../../src/go/types/typeset.go.html#line-232" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-232">#L232</a>: 				err.addf(atPos(mpos[other.(*Func)]), "other declaration of method %s", m.<b>name</b>)
		<a href="../../src/go/types/typeset.go.html#line-245" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-245">#L245</a>: 						err.addf(atPos(pos), "duplicate method %s", m.<b>name</b>)
		<a href="../../src/go/types/typeset.go.html#line-246" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-246">#L246</a>: 						err.addf(atPos(mpos[other.(*Func)]), "other declaration of method %s", m.<b>name</b>)
		<a href="../../src/go/types/typeset.go.html#line-249" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-249">#L249</a>: 				}).describef(atPos(pos), "duplicate method check for %s", m.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-158">typestring.go#L158</a>: 			if w.qf == nil &amp;&amp; w.pkgInfo &amp;&amp; !isExported(f.<b>name</b>) {
		<a href="../../src/go/types/typestring.go.html#line-168" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-168">#L168</a>: 				w.string(f.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-249" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-249">#L249</a>: 				w.string(m.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-320" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-320">#L320</a>: 			w.string(t.obj.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-328" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-328">#L328</a>: 			if w.ctxt == nil &amp;&amp; Universe.Lookup(t.obj.<b>name</b>) != nil {
		<a href="../../src/go/types/typestring.go.html#line-330" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-330">#L330</a>: 					w.string(fmt.Sprintf(" /* with %s declared at %v */", t.obj.<b>name</b>, t.obj.Pos()))
		<a href="../../src/go/types/typestring.go.html#line-369" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-369">#L369</a>: 		w.string(m.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-438" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-438">#L438</a>: 	w.string(obj.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-449" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-449">#L449</a>: 			if w.ctxt == nil &amp;&amp; v.<b>name</b> != "" &amp;&amp; w.paramNames {
		<a href="../../src/go/types/typestring.go.html#line-450" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-450">#L450</a>: 				w.string(v.<b>name</b>)
		<a href="../../src/go/types/typestring.go.html#line-497" class="path-duplicate">typestring.go</a><a href="../../src/go/types/typestring.go.html#line-497">#L497</a>: 	if n == 1 &amp;&amp; (w.ctxt != nil || sig.results.vars[0].<b>name</b> == "") {
		<a href="../../src/go/types/typexpr.go.html#line-90">typexpr.go#L90</a>: 		check.errorf(e, InvalidPkgUse, "use of package %s not in selector", obj.<b>name</b>)
		<a href="../../src/go/types/typexpr.go.html#line-112" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-112">#L112</a>: 			check.errorf(e, InvalidDeclCycle, "invalid use of type alias %s in recursive type (see go.dev/issue/50729)", obj.<b>name</b>)
		<a href="../../src/go/types/typexpr.go.html#line-483" class="path-duplicate">typexpr.go</a><a href="../../src/go/types/typexpr.go.html#line-483">#L483</a>: 		name := inst.(interface{ Obj() *TypeName }).Obj().<b>name</b>
		<a href="../../src/go/types/unify.go.html#line-542">unify.go#L542</a>: 				obj, _, _ := LookupFieldOrMethod(y, false, xm.pkg, xm.<b>name</b>)
		<a href="../../src/go/types/unify.go.html#line-615" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-615">#L615</a>: 						!f.sameId(g.pkg, g.<b>name</b>, false) ||
		<a href="../../src/go/types/universe.go.html#line-169">universe.go#L169</a>: 	def(&amp;Nil{object{<b>name</b>: "nil", typ: Typ[UntypedNil], color_: black}})
</code></pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.7.6</i>. (GOOS=linux GOARCH=amd64)</pre>