<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>References: go/types.Func</title>
<link href="../../css/auto-v0.7.6.css" rel="stylesheet">
<script src="../../jvs/golds-v0.7.6.js"></script>
<body onload="onPageLoad()"><div>

<pre><code><span style="font-size:x-large;">type <b><a href="../../pkg/go/types.html">go/types</a>.<a href="../../src/go/types/object.go.html#line-439">Func</a></b></span>

<span class="title">113 uses</span>

	go/types (current package)
		<a href="../../src/go/types/builtins.go.html#line-770">builtins.go#L770</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/call.go.html#line-760">call.go#L760</a>: 			case *<b>Func</b>:
		<a href="../../src/go/types/call.go.html#line-849" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-849">#L849</a>: 	if m, _ := obj.(*<b>Func</b>); m != nil {
		<a href="../../src/go/types/call.go.html#line-855" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-855">#L855</a>: 		m, _ := obj.(*<b>Func</b>)
		<a href="../../src/go/types/call.go.html#line-912" class="path-duplicate">call.go</a><a href="../../src/go/types/call.go.html#line-912">#L912</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/check.go.html#line-194">check.go#L194</a>: 	methods  map[*TypeName][]*<b>Func</b> // maps package scope type names to associated non-blank (non-interface) methods
		<a href="../../src/go/types/decl.go.html#line-158">decl.go#L158</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/decl.go.html#line-203" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-203">#L203</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/decl.go.html#line-268" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-268">#L268</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/decl.go.html#line-831" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-831">#L831</a>: 					_ = alt.(*<b>Func</b>)
		<a href="../../src/go/types/decl.go.html#line-845" class="path-duplicate">decl.go</a><a href="../../src/go/types/decl.go.html#line-845">#L845</a>: func (check *Checker) funcDecl(obj *<b>Func</b>, decl *declInfo) {
		<a href="../../src/go/types/errsupport.go.html#line-89">errsupport.go#L89</a>: 		case *<b>Func</b>:
		<a href="../../src/go/types/initorder.go.html#line-256">initorder.go#L256</a>: 		if _, ok := n.obj.(*<b>Func</b>); ok {
		<a href="../../src/go/types/interface.go.html#line-19">interface.go#L19</a>: 	methods   []*<b>Func</b>      // ordered list of explicitly declared methods
		<a href="../../src/go/types/interface.go.html#line-39" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-39">#L39</a>: func NewInterface(methods []*<b>Func</b>, embeddeds []*Named) *Interface {
		<a href="../../src/go/types/interface.go.html#line-53" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-53">#L53</a>: func NewInterfaceType(methods []*<b>Func</b>, embeddeds []Type) *Interface {
		<a href="../../src/go/types/interface.go.html#line-98" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-98">#L98</a>: func (t *Interface) ExplicitMethod(i int) *<b>Func</b> { return t.methods[i] }
		<a href="../../src/go/types/interface.go.html#line-117" class="path-duplicate">interface.go</a><a href="../../src/go/types/interface.go.html#line-117">#L117</a>: func (t *Interface) Method(i int) *<b>Func</b> { return t.typeSet().Method(i) }
		<a href="../../src/go/types/iter.go.html#line-20">iter.go#L20</a>: func (t *Interface) Methods() iter.Seq[*<b>Func</b>] {
		<a href="../../src/go/types/iter.go.html#line-21" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-21">#L21</a>: 	return func(yield func(m *<b>Func</b>) bool) {
		<a href="../../src/go/types/iter.go.html#line-34" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-34">#L34</a>: func (t *Interface) ExplicitMethods() iter.Seq[*<b>Func</b>] {
		<a href="../../src/go/types/iter.go.html#line-35" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-35">#L35</a>: 	return func(yield func(m *<b>Func</b>) bool) {
		<a href="../../src/go/types/iter.go.html#line-60" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-60">#L60</a>: func (t *Named) Methods() iter.Seq[*<b>Func</b>] {
		<a href="../../src/go/types/iter.go.html#line-61" class="path-duplicate">iter.go</a><a href="../../src/go/types/iter.go.html#line-61">#L61</a>: 	return func(yield func(m *<b>Func</b>) bool) {
		<a href="../../src/go/types/lookup.go.html#line-43">lookup.go#L43</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/lookup.go.html#line-105" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-105">#L105</a>: 			if _, ok := obj.(*<b>Func</b>); ok {
		<a href="../../src/go/types/lookup.go.html#line-260" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-260">#L260</a>: 			if f, _ := obj.(*<b>Func</b>); f != nil {
		<a href="../../src/go/types/lookup.go.html#line-365" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-365">#L365</a>: func MissingMethod(V Type, T *Interface, static bool) (method *<b>Func</b>, wrongType bool) {
		<a href="../../src/go/types/lookup.go.html#line-378" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-378">#L378</a>: func (check *Checker) missingMethod(V, T Type, static bool, equivalent func(x, y Type) bool, cause *string) (method *<b>Func</b>, wrongType bool) {
		<a href="../../src/go/types/lookup.go.html#line-396" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-396">#L396</a>: 	var m *<b>Func</b> // method on T we're trying to implement
		<a href="../../src/go/types/lookup.go.html#line-397" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-397">#L397</a>: 	var f *<b>Func</b> // method on V, if found (state is one of ok, wrongName, wrongSig)
		<a href="../../src/go/types/lookup.go.html#line-431" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-431">#L431</a>: 					f, _ = obj.(*<b>Func</b>)
		<a href="../../src/go/types/lookup.go.html#line-445" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-445">#L445</a>: 			f, _ = obj.(*<b>Func</b>)
		<a href="../../src/go/types/lookup.go.html#line-570" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-570">#L570</a>: func (check *Checker) funcString(f *<b>Func</b>, pkgInfo bool) string {
		<a href="../../src/go/types/lookup.go.html#line-666" class="path-duplicate">lookup.go</a><a href="../../src/go/types/lookup.go.html#line-666">#L666</a>: func methodIndex(methods []*<b>Func</b>, pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/methodset.go.html#line-218">methodset.go#L218</a>: func (s methodSet) add(list []*<b>Func</b>, index []int, indirect bool, multiples bool) methodSet {
		<a href="../../src/go/types/methodset.go.html#line-228" class="path-duplicate">methodset.go</a><a href="../../src/go/types/methodset.go.html#line-228">#L228</a>: func (s methodSet) addOne(f *<b>Func</b>, index []int, indirect bool, multiples bool) methodSet {
		<a href="../../src/go/types/named.go.html#line-131">named.go#L131</a>: 	methods []*<b>Func</b>
		<a href="../../src/go/types/named.go.html#line-134" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-134">#L134</a>: 	loader func(*Named) (tparams []*TypeParam, underlying Type, methods []*<b>Func</b>)
		<a href="../../src/go/types/named.go.html#line-158" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-158">#L158</a>: func NewNamed(obj *TypeName, underlying Type, methods []*<b>Func</b>) *Named {
		<a href="../../src/go/types/named.go.html#line-243" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-243">#L243</a>: func (check *Checker) newNamed(obj *TypeName, underlying Type, methods []*<b>Func</b>) *Named {
		<a href="../../src/go/types/named.go.html#line-358" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-358">#L358</a>: func (t *Named) Method(i int) *<b>Func</b> {
		<a href="../../src/go/types/named.go.html#line-373" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-373">#L373</a>: 		t.methods = make([]*<b>Func</b>, len(orig.methods))
		<a href="../../src/go/types/named.go.html#line-394" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-394">#L394</a>: func (t *Named) expandMethod(i int) *<b>Func</b> {
		<a href="../../src/go/types/named.go.html#line-470" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-470">#L470</a>: func (t *Named) AddMethod(m *<b>Func</b>) {
		<a href="../../src/go/types/named.go.html#line-608" class="path-duplicate">named.go</a><a href="../../src/go/types/named.go.html#line-608">#L608</a>: func (n *Named) lookupMethod(pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/object.go.html#line-299">object.go#L299</a>: func _NewTypeNameLazy(pos token.Pos, pkg *Package, name string, load func(named *Named) (tparams []*TypeParam, underlying Type, methods []*<b>Func</b>)) *TypeName {
		<a href="../../src/go/types/object.go.html#line-439" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-439">#L439</a>: type <b>Func</b> struct {
		<a href="../../src/go/types/object.go.html#line-442" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-442">#L442</a>: 	origin      *<b>Func</b> // if non-nil, the Func from which this one was instantiated
		<a href="../../src/go/types/object.go.html#line-447" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-447">#L447</a>: func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *<b>Func</b> {
		<a href="../../src/go/types/object.go.html#line-457" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-457">#L457</a>: 	return &amp;<b>Func</b>{object{nil, pos, pkg, name, typ, 0, colorFor(typ), nopos}, false, nil}
		<a href="../../src/go/types/object.go.html#line-461" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-461">#L461</a>: func (obj *<b>Func</b>) Signature() *Signature {
		<a href="../../src/go/types/object.go.html#line-478" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-478">#L478</a>: func (obj *<b>Func</b>) FullName() string {
		<a href="../../src/go/types/object.go.html#line-487" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-487">#L487</a>: func (obj *<b>Func</b>) Scope() *Scope { return obj.typ.(*Signature).scope }
		<a href="../../src/go/types/object.go.html#line-496" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-496">#L496</a>: func (obj *<b>Func</b>) Origin() *<b>Func</b> {
		<a href="../../src/go/types/object.go.html#line-507" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-507">#L507</a>: func (obj *<b>Func</b>) Pkg() *Package { return obj.object.Pkg() }
		<a href="../../src/go/types/object.go.html#line-510" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-510">#L510</a>: func (obj *<b>Func</b>) hasPtrRecv() bool {
		<a href="../../src/go/types/object.go.html#line-528" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-528">#L528</a>: func (*<b>Func</b>) isDependency() {} // a function may be a dependency of an initialization expression
		<a href="../../src/go/types/object.go.html#line-587" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-587">#L587</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/object.go.html#line-689" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-689">#L689</a>: func (obj *<b>Func</b>) String() string     { return ObjectString(obj, nil) }
		<a href="../../src/go/types/object.go.html#line-694" class="path-duplicate">object.go</a><a href="../../src/go/types/object.go.html#line-694">#L694</a>: func writeFuncName(buf *bytes.Buffer, f *<b>Func</b>, qf Qualifier) {
		<a href="../../src/go/types/resolver.go.html#line-231">resolver.go#L231</a>: 		obj  *<b>Func</b>      // method
		<a href="../../src/go/types/resolver.go.html#line-490" class="path-duplicate">resolver.go</a><a href="../../src/go/types/resolver.go.html#line-490">#L490</a>: 	check.methods = make(map[*TypeName][]*<b>Func</b>)
		<a href="../../src/go/types/selection.go.html#line-100">selection.go#L100</a>: 		sig := *s.obj.(*<b>Func</b>).typ.(*Signature)
		<a href="../../src/go/types/selection.go.html#line-111" class="path-duplicate">selection.go</a><a href="../../src/go/types/selection.go.html#line-111">#L111</a>: 		sig := *s.obj.(*<b>Func</b>).typ.(*Signature)
		<a href="../../src/go/types/subst.go.html#line-332">subst.go#L332</a>: func (subst *subster) func_(f *<b>Func</b>) *<b>Func</b> {
		<a href="../../src/go/types/subst.go.html#line-341" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-341">#L341</a>: func cloneFunc(f *<b>Func</b>, typ Type) *<b>Func</b> {
		<a href="../../src/go/types/subst.go.html#line-361" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-361">#L361</a>: func replaceRecvType(in []*<b>Func</b>, old, new Type) (out []*<b>Func</b>, copied bool) {
		<a href="../../src/go/types/subst.go.html#line-370" class="path-duplicate">subst.go</a><a href="../../src/go/types/subst.go.html#line-370">#L370</a>: 				out = make([]*<b>Func</b>, len(in))
		<a href="../../src/go/types/typeset.go.html#line-30">typeset.go#L30</a>: 	methods    []*<b>Func</b>  // all methods of the interface; sorted by unique ID
		<a href="../../src/go/types/typeset.go.html#line-59" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-59">#L59</a>: func (s *_TypeSet) Method(i int) *<b>Func</b> { return s.methods[i] }
		<a href="../../src/go/types/typeset.go.html#line-62" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-62">#L62</a>: func (s *_TypeSet) LookupMethod(pkg *Package, name string, foldCase bool) (int, *<b>Func</b>) {
		<a href="../../src/go/types/typeset.go.html#line-221" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-221">#L221</a>: 	var allMethods []*<b>Func</b>
		<a href="../../src/go/types/typeset.go.html#line-222" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-222">#L222</a>: 	mpos := make(map[*<b>Func</b>]token.Pos) // method specification or method embedding position, for good error messages
		<a href="../../src/go/types/typeset.go.html#line-223" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-223">#L223</a>: 	addMethod := func(pos token.Pos, m *<b>Func</b>, explicit bool) {
		<a href="../../src/go/types/typeset.go.html#line-232" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-232">#L232</a>: 				err.addf(atPos(mpos[other.(*<b>Func</b>)]), "other declaration of method %s", m.name)
		<a href="../../src/go/types/typeset.go.html#line-246" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-246">#L246</a>: 						err.addf(atPos(mpos[other.(*<b>Func</b>)]), "other declaration of method %s", m.name)
		<a href="../../src/go/types/typeset.go.html#line-351" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-351">#L351</a>: func compareFunc(a, b *<b>Func</b>) int {
		<a href="../../src/go/types/typeset.go.html#line-355" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-355">#L355</a>: func sortMethods(list []*<b>Func</b>) {
		<a href="../../src/go/types/typeset.go.html#line-359" class="path-duplicate">typeset.go</a><a href="../../src/go/types/typeset.go.html#line-359">#L359</a>: func assertSortedMethods(list []*<b>Func</b>) {
		<a href="../../src/go/types/typexpr.go.html#line-130">typexpr.go#L130</a>: 	case *<b>Func</b>:
		<a href="../../src/go/types/unify.go.html#line-516">unify.go#L516</a>: 			ymap := make(map[string]*<b>Func</b>, len(ymethods))
		<a href="../../src/go/types/unify.go.html#line-543" class="path-duplicate">unify.go</a><a href="../../src/go/types/unify.go.html#line-543">#L543</a>: 				if ym, _ := obj.(*<b>Func</b>); ym == nil || !u.nify(xm.typ, ym.typ, exact, p) {
		<a href="../../src/go/types/universe.go.html#line-131">universe.go#L131</a>: 		ityp := &amp;Interface{methods: []*<b>Func</b>{err}, complete: true}

	<a href="../../pkg/golang.org/x/exp/apidiff.html">golang.org/x/exp/apidiff</a>
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-250">apidiff.go#L250</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-252" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-252">#L252</a>: 		case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-296" class="path-duplicate">apidiff.go</a><a href="../../src/golang.org/x/exp/apidiff/apidiff.go.html#line-296">#L296</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/exp/apidiff/compatibility.go.html#line-127">compatibility.go#L127</a>: func unexportedMethod(t *types.Interface) *types.<b>Func</b> {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-273">correspondence.go#L273</a>: func (d *differ) sortedMethods(iface *types.Interface) []*types.<b>Func</b> {
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-274" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-274">#L274</a>: 	ms := make([]*types.<b>Func</b>, iface.NumMethods())
		<a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-282" class="path-duplicate">correspondence.go</a><a href="../../src/golang.org/x/exp/apidiff/correspondence.go.html#line-282">#L282</a>: func (d *differ) methodID(m *types.<b>Func</b>) string {
		<a href="../../src/golang.org/x/exp/apidiff/messageset.go.html#line-90">messageset.go#L90</a>: 	if f, ok := obj.(*types.<b>Func</b>); ok {

	<a href="../../pkg/golang.org/x/tools/go/types/objectpath.html">golang.org/x/tools/go/types/objectpath</a>
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-250">objectpath.go#L250</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-358" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-358">#L358</a>: func (enc *Encoder) concreteMethod(meth *types.<b>Func</b>) (Path, bool) {
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-465" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-465">#L465</a>: 	seenMethods     map[*types.<b>Func</b>]bool     // for cycle breaking through recursive interfaces
		<a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-535" class="path-duplicate">objectpath.go</a><a href="../../src/golang.org/x/tools/go/types/objectpath/objectpath.go.html#line-535">#L535</a>: 				f.seenMethods = make(map[*types.<b>Func</b>]bool)

	<a href="../../pkg/golang.org/x/tools/go/types/typeutil.html">golang.org/x/tools/go/types/typeutil</a>
		<a href="../../src/golang.org/x/tools/go/types/typeutil/callee.go.html#line-36">callee.go#L36</a>: func StaticCallee(info *types.Info, call *ast.CallExpr) *types.<b>Func</b> {
		<a href="../../src/golang.org/x/tools/go/types/typeutil/callee.go.html#line-38" class="path-duplicate">callee.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/callee.go.html#line-38">#L38</a>: 	fn, _ := obj.(*types.<b>Func</b>)
		<a href="../../src/golang.org/x/tools/go/types/typeutil/callee.go.html#line-82" class="path-duplicate">callee.go</a><a href="../../src/golang.org/x/tools/go/types/typeutil/callee.go.html#line-82">#L82</a>: func interfaceMethod(f *types.<b>Func</b>) bool {

	<a href="../../pkg/golang.org/x/tools/internal/gcimporter.html">golang.org/x/tools/internal/gcimporter</a>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iexport.go.html#line-716">iexport.go#L716</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-952">iimport.go#L952</a>: 		methods := make([]*types.<b>Func</b>, r.uint64())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-954" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-954">#L954</a>: 			var method *types.<b>Func</b>
		<a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-956" class="path-duplicate">iimport.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/iimport.go.html#line-956">#L956</a>: 				method, _ = r.objectPathObject().(*types.<b>Func</b>)
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-413">ureader_yes.go#L413</a>: 	methods := make([]*types.<b>Func</b>, r.Len())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-570" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-570">#L570</a>: 					methods := make([]*types.<b>Func</b>, iface.NumExplicitMethods())
		<a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-717" class="path-duplicate">ureader_yes.go</a><a href="../../src/golang.org/x/tools/internal/gcimporter/ureader_yes.go.html#line-717">#L717</a>: func (r *reader) method() *types.<b>Func</b> {

	<a href="../../pkg/golang.org/x/tools/internal/typesinternal.html">golang.org/x/tools/internal/typesinternal</a>
		<a href="../../src/golang.org/x/tools/internal/typesinternal/classify_call.go.html#line-78">classify_call.go#L78</a>: 	case *types.<b>Func</b>:
		<a href="../../src/golang.org/x/tools/internal/typesinternal/classify_call.go.html#line-137" class="path-duplicate">classify_call.go</a><a href="../../src/golang.org/x/tools/internal/typesinternal/classify_call.go.html#line-137">#L137</a>: func interfaceMethod(f *types.<b>Func</b>) bool
</code></pre><pre id="footer">
The pages are generated with <a href="https://go101.org/apps-and-libs/golds.html"><b>Golds</b></a> <i>v0.7.6</i>. (GOOS=linux GOARCH=amd64)</pre>